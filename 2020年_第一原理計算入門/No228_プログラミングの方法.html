<p>　ここでは、学部4年生から大学院生M2及びD3までの方を対象に、第一原理計算コードのセットアップから、計算方法、結果の解釈、Fortran やC言語、pythonを用いた第一理計算のプログラミングからigor macroを用いた解析までを解説していきます。（社会人でもOK)<br />
&nbsp; 下記のHPが非常に良い（lapackの使い方まで解説されている）。Lapackは日本語の書籍もあることは認識しておきたい。<br />
&nbsp; <a href="http://www.rcs.arch.t.u-tokyo.ac.jp/kusuhara/tips/linux/fortran.html">http://www.rcs.arch.t.u-tokyo.ac.jp/kusuhara/tips/linux/fortran.html</a><br />
下記も参照すると良い。<br />
<a href="http://www.phys.keio.ac.jp/guidance/labs/riron/pdf/nosenote1.pdf">http://www.phys.keio.ac.jp/guidance/labs/riron/pdf/nosenote1.pdf</a>　<br />
<a href="http://www.phys.keio.ac.jp/guidance/labs/riron/pdf/nosenote2.pdf">http://www.phys.keio.ac.jp/guidance/labs/riron/pdf/nosenote2.pdf</a>　<br />
<a href="http://www.phys.keio.ac.jp/guidance/labs/riron/pdf/nosenote3.pdf">http://www.phys.keio.ac.jp/guidance/labs/riron/pdf/nosenote3.pdf</a>　<br />
<a href="http://ci.nii.ac.jp/naid/110002066105">http://ci.nii.ac.jp/naid/110002066105</a><br />
<a href="http://tkkoba.blog.fc2.com/blog-category-1.html">http://tkkoba.blog.fc2.com/blog-category-1.html</a> (多くの情報がある)<br />
--------------------------------------------------------------------------------<br />
■ 博士論文（D論）は卒業論文や修士論文と異なり、新規性があり、成功した成果を記さねばなりません。ここで重要になるのがプログラミングです。これができると第一原理計算から出力された結果を利用して種々の計算が可能になりますし、時間の短縮とミスの減少を成し遂げることができます。<br />
　水島二郎ら「理工学のための数値計算法」数理工学社<br />
◇ 最近 Fortran90/95に対して大変良い良書が出版された。下記である。<br />
　藤井文夫ら『Fortran90/95 による有限要素法プログラミング』丸善出版<br />
数年前に出版されていればここまで苦労しなかったのに......。私の人生も少しは変わっていた。<br />
　田口俊弘『Fortranハンドブック』技術評論社 はAkaiKKRの理解に役立つかもしれない。<br />
--------------------------------------------------------------------------------<br />
■ Linux OS上でソースコードを書くための便利な環境設定<br />
&nbsp; CentOS、Fedora, Ubuntuなどでのtext editorの場合<br />
&nbsp;&nbsp;&nbsp; 1) view&rarr;Highlight Mode&rarr;Sources&rarr;Fortran 95を選択する<br />
&nbsp;&nbsp;&nbsp; 2) Edit&rarr;Preference&rarr;Line Numbers のDisplay line numbersにチェックを入れる<br />
&nbsp;&nbsp;&nbsp; 3) Edit&rarr;Preference&rarr;Right MarginのDisplay line marginにもチェックを入れる<br />
&nbsp;&nbsp;&nbsp; 4) Edit&rarr;Preference&rarr;Font&amp;ColorsのEditor fontで見やすいフォントと大きさを設定<br />
&nbsp; としておくと便利です。（Sourcesには他の言語に対するものもあります）<br />
--------------------------------------------------------------------------------<br />
■ エディタ<br />
　使いやすいものとしては gedit, kwrite, kate, emacs, vi&nbsp;などがある。<br />
　windowsに慣れているユーザーでは geditが使いやすい。<br />
--------------------------------------------------------------------------------<br />
■ Fortran及び理論計算のプログラム<br />
　WIEN2kのコードを見ていて思ったが、英文字に大文字と小文字の区別無しに記述されている部分がある。可読性という点からはあまり好ましくは無い。Frotran90/95では英文字での大文字と小文字が区別されないことにも注意しておきたい。<br />
<br />
&nbsp; 下記の参考文献[1-11]を用いて、実際のFortranプログラムを勉学しながら計算コードを作成すると効率的に理解を深めることができます。ここでは、これらの参考文献を用いて、第一原理計算コードで要となるアルゴリズムやプログラムの解説を行います。<br />
　制御文は難しくないので、Fortranとしては、ファイルの読み書き、F90以降から追加された機能について説明します。（編集中）<br />
<br />
&nbsp; 理論計算で重要なアルゴリズム及びプログラムは以下になります。対角化は理論だけは理解して、ライブラリを活用するのが良いでしょう。<br />
<br />
□ ベルレ法（Verlet法）[V1]<br />
　速度Verlet法は、原子の位置r<sub>i</sub>(t&plusmn;&Delta;t)のt=tの周りでの&Delta;tの3次のテーラー展開からも、また時間発展演算子の対称化されたトロッタ分解からも求められ、速度と位置に対して以下のような時間発展をします。<br />
　v<sub>i</sub>(t) = v<sub>i</sub>(t-&Delta;t) + (&Delta;t/m<sub>i</sub>) * (F<sub>i</sub>(t) + F<sub>i</sub>(t-&Delta;t))/2<br />
　r<sub>i</sub>(t+&Delta;t) = r<sub>i</sub>(t) + &Delta;t*v<sub>i</sub>(t) + (&Delta;t<sup>2</sup>/(2*m<sub>i</sub>))*F<sub>i</sub>(t) + O(&Delta;t<sup>4</sup>)<br />
位置は&Delta;t<sup><font size="2">4</font></sup>の誤差を含みますが、原子系では通常&Delta;t=1-2fsとすれば十分精度よく運動方程式を解くことができます。<br />
[V1] 応用物理 第86巻 第11号 p.988 (2017)<br />
<br />
□ シュレーディンガー方程式の動径部分の解法[H1]<br />
　下記のHPでシュレーディンガー方程式の動径部分をルンゲクッタ法で解く方法が解説されている。<br />
　<a href="http://navi.cs.kumamoto-u.ac.jp/~koutaki/pukiwiki/index.php?%C5%C5%BB%D2%BE%F5%C2%D6%B7%D7%BB%BB">http://navi.cs.kumamoto-u.ac.jp/~koutaki/pukiwiki/index.php?%C5%C5%BB%D2%BE%F5%C2%D6%B7%D7%BB%BB</a><br />
　ハミング（Hamming）法も、２階の微分方程式である「シュレーディンガー方程式の動径部分」を１階の連立微分方程式に変えて計算する。具体的には下記のような「シュレーディンガー方程式の動径部分」が得られる（r=exp(X)ともしている）。<br />
　d<sup>2</sup>L/dX<sup>2</sup> = B*L - (2*l + 1)*dL/dX<br />
ここで、B=r(r*V(r) - r*&epsilon;), V(r)と&epsilon;は シュレーディンガー方程式の{-(1/2)*&nabla;<sup>2</sup> + V(r)}*&psi;(r) = &epsilon;*&psi;(r)に対応する。<br />
d<sup><font size="2">2</font></sup>L/dX<sup><font size="2">2</font></sup> -&gt; y'と考えて、dL/Dx -&gt; yとしてdL/dXが得られる。<br />
（d<sup><font size="2">2</font></sup>L/dX<sup><font size="2">2</font></sup>-&gt; y'、&nbsp;B*L - (2*l + 1)*dL/dX -&gt; f(x,y), X-&gt; xとおいて一般的に考えることができる）<br />
次に、dL/dX -&gt; y'と考えて、L -&gt; y を得る。<br />
<br />
□ ハミング（Hamming）法（+予測子修正子法）<br />
　常微分方程式の数値解法には様々な手法があるが、そのうちの一つに線形多段解法であるHamming方がある。Hamming法では以下の手順で数値解を得る。<br />
1) 予測子を用いて予測値を計算する<br />
2) 補正子を用いて補正する<br />
3) 補正値に対して修正子を用いて修正する<br />
4) 修正値を予測値から直接解を得る<br />
大もとの問題は<br />
　y' = f(x,y), y(a)=&eta;<br />
であった。これに対して積分を続け、y<sub>i</sub>まで解が求められているときy<sub>i+1</sub>求めるには、予測子公式<br />
　y<sup>p</sup><sub>i+1</sub> = y<sub>i-3</sub> + (4/3)*(2*f<sub>i</sub> - f<sub>i-1</sub> + 2*f<sub>i-2</sub>)<br />
によって予測子y<font size="2"><sup>p</sup><sub>i+1</sub></font> を求めこれを補正子公式<br />
　y<font size="2"><sup>m</sup><sub>i+1</sub></font> =&nbsp;y<font size="2"><sup>p</sup><sub>i+1</sub></font>&nbsp;&nbsp;- (112/121)*(y<font size="2"><sup>p</sup><sub>i</sub></font>&nbsp;- y<font size="2"><sup>c</sup><sub>i</sub></font> )<br />
に代入して補正子y<font size="2"><sup>m</sup><sub>i+1</sub></font> を求める。ここでの補正値を修正子公式<br />
　y<font size="2"><sup>c</sup><sub>i+1 </sub></font>= (1/8)*{9*y<sub><font size="2">i</font></sub> - y<sub><font size="2">i-2 </font></sub>+ 3*h*(f(x<sub>x+1</sub>, y<sup>m</sup><sub>i+1</sub>) + 2*f<sub>i-1</sub> - f<sub>i-2</sub>)<br />
に代入して修正値y<font size="2"><sup>c</sup><sub>i+1</sub></font>を求め、解y<font size="2"><sub>i+1</sub></font>を得る。<br />
　y<font size="2"><sub>i+1 </sub></font>= y<font size="2"><sup>c</sup><sub>i+1&nbsp;</sub></font> + (9/121)*(y<font size="2"><sup>p</sup><sub>i+1</sub></font> - y<font size="2"><sup>c</sup><sub>i+1</sub></font>)&nbsp;<br />
出発値y<sub>1</sub>, y<sub>2</sub>, y<sub>3</sub>は別の方法で得られているものとする。また、y<sup>p</sup><sub>3</sub> - y<sup>c</sup><sub>3</sub> = 0とする。<br />
[H1] 岩沢美佐子、足立裕彦「DV-X&alpha;法による電子状態計算 -そのプログラムと解説-」三共出版株式会社<br />
[P1] アダムス・モルトンの予測子修正子法：<a href="http://www.geocities.jp/java_sample_program/AdamsMoltonHou.pdf">http://www.geocities.jp/java_sample_program/AdamsMoltonHou.pdf</a><br />
<br />
□ 大規模計算用のテクニック[H1]<br />
「実空間でのFock行列及び重なり行列は実対称行列になるので、下三角部分のみ計算し、一次元化して配列に記録する。また、対称軌道を用いる場合は、各対称性に関して行列がブロックアウトする。そこで、その各ブロックの下三角部分を一次元化していく。対称性に関して縮退がある場合は、縮退度分足し込んで各行列要素が得られる」といった手法を用いて使用するメモリを減らす（場合によっては、次元を低下させることでデータの読み込み速度の高速化をし易くしている）<br />
<br />
□ ライブラリの活用[L1, L2]<br />
　左欄にあるライブラリの設定を参照してください。Lapackなどは英語が読めないと、誰かが説明を日本語で説明を書いてくれないと辛い。Lapackについては、下記のHPでいくつか丁寧に解説されている。これを読むと英語が得意だったらどれだけ楽だったことかと思わずにはいられない。<br />
　分子軌道計算で用いられている例として、実対称/エルミート定値な行列をもつ一般固有値問題の解法ルーチン[dsygv]を下記で見てみる。<br />
　call dsygv(計算している行列の形式を指定（1だとF*C=E*S*C）、固有値だけか固有ベクトルも計算するか（Vだと両方を出力）、上三角行列か下三角行列のどちらを格納するかを指定（Uだと上三角行列）、Fock行列の次元、Fock行列（固有ベクトルを出力させるようにしてinfo=0の指定で出力時に正規化された固有ベクトルが格納される）、重なり行列Sの次元、重なり行列S、固有値の次元、固有値E（昇順）、work、lwork、info)<br />
[L1] ルーチンの仕様: <a href="http://www.cazoo.jp/calcsoft/library/lapack/clapack/usage/index.html">http://www.cazoo.jp/calcsoft/library/lapack/clapack/usage/index.html</a><br />
[L2] LapackをC++で使う：<a href="http://www-cms.phys.s.u-tokyo.ac.jp/~naoki/CIPINTRO/LAPACK/">http://www-cms.phys.s.u-tokyo.ac.jp/~naoki/CIPINTRO/LAPACK/</a><br />
<br />
参考文献<br />
[0] <a href="http://denki.nara-edu.ac.jp/%7Eyabu/soft/fortran.html">http://denki.nara-edu.ac.jp/~yabu/soft/fortran.html</a><br />
[1] 日野理 著、『実践 量子化学計算プログラミング』、アドバンスソフト、(2010).<br />
[2] 山口 憲　　冨澤 一隆 著、『非平衡電子輸送論』、アドバンスソフト、(2011).<br />
[3] 湊 明彦 著、『気液二相流の力学と数値解析入門』、アドバンスソフト、(2009).<br />
[4]&nbsp;岩沢美佐子、足立裕彦 著、『DV-X alpha法による電子状態計算-そのプログラムと解説』、三共出版、（1996).<br />
[5] 渡辺力、名取亮、小国力監修、『Fortran77による数値計算ソフトウェア』、丸善<br />
[6] E. Andersonら、小国力訳、『行列計算パッケージ：LAPACK利用の手引』、丸善<br />
[7] <a href="http://www-aos.eps.s.u-tokyo.ac.jp/%7Etakagi/f77-enshu/text/f77-20050419.pdf">http://www-aos.eps.s.u-tokyo.ac.jp/~takagi/f77-enshu/text/f77-20050419.pdf</a><br />
[8] <a href="http://www-aos.eps.s.u-tokyo.ac.jp/%7Etakagi/lecture/f90-enshu/text/f90-20090418.pdf">http://www-aos.eps.s.u-tokyo.ac.jp/~takagi/lecture/f90-enshu/text/f90-20090418.pdf</a><br />
[9] <a href="http://www.mri-jma.go.jp/Project/mrinpd/coderule.html">http://www.mri-jma.go.jp/Project/mrinpd/coderule.html</a><br />
[10] <a href="http://www.gfd-dennou.org/library/dcmodel/coding-rules/dcmodel-coding-rules.htm">http://www.gfd-dennou.org/library/dcmodel/coding-rules/dcmodel-coding-rules.htm</a><br />
[11]&nbsp;<a href="http://wind.geophys.tohoku.ac.jp/nonhydro/workshop/third/draft/3_toyoda.pdf">http://wind.geophys.tohoku.ac.jp/nonhydro/workshop/third/draft/3_toyoda.pdf</a>&nbsp;<br />
[12] <a href="http://www-aos.eps.s.u-tokyo.ac.jp/%7Etakagi/lecture/f90-enshu/index.html">http://www-aos.eps.s.u-tokyo.ac.jp/~takagi/lecture/f90-enshu/index.html</a><br />
[13] <a href="http://www.jamstec.go.jp/esc/simschool/f90learning/">http://www.jamstec.go.jp/esc/simschool/f90learning/</a><br />
--------------------------------------------------------------<br />
■ 64&nbsp;bit 計算が出来ない場合<br />
　Fortran のソースコードにおいて大きなメモリが必要となる配列をCOMMON文からallocate 文に書き換える。<br />
（intel fortran compiler では特にこれが重要。Akai-KKRでは2018年3月12日に実装された。これでより大きな系が計算できる。SPR-KKRよりもAkai-KKRの方が幾つかの系でエラー無く計算できることがあるので嬉しい。もっと早く実装されればありがたかったが......。私が研究者として強制的にリタイアさせられた後とは皮肉なものだ）<br />
<br />
□ コンパイル&nbsp;オプションでの問題<br />
・ windows OS の場合 : 下記参考文献 [1] を参照<br />
&nbsp; Fortran のソースコードにおいて大きなメモリが必要となる配列をCOMMON文からallocate 文に書き換える。<br />
<br />
・ Linux OS の場合 : 下記参考文献 [2-6] を参照<br />
&nbsp;&nbsp;-mcmodel=large や -m64 などのオプションを追加して下さい。<br />
&nbsp; ifort -mcmodel=large&nbsp;-o case.f case<br />
&nbsp;&nbsp;ifort -mcmodel=large -i-dynamic -o case.f case<br />
&nbsp;&nbsp;ifort -shared-intel -mcmodel=large -o case.f case<br />
&nbsp; gfortran -m64 -o case.f case<br />
<br />
□ メモリ使用制限の問題 [7]<br />
&nbsp; Linux OS では下記のように対処する方法がある<br />
&nbsp; ulimit -a で max memory size が unlimited であるかを確認<br />
&nbsp; メモリ使用量を無制限にするには、ulimit -m unlimited とする。計算用のPCであれば、.bashrc に下記を記入しておいても良いだろう。<br />
&nbsp; ulimit -s unlimited<br />
&nbsp; ulimit -v unlimited<br />
&nbsp; ulimit -m unlimited<br />
<br />
References<br />
[1] <a href="http://www.softek.co.jp/SPG/Pgi/TIPS/opt_64.html">http://www.softek.co.jp/SPG/Pgi/TIPS/opt_64.html</a><br />
[2] <a href="http://www.hpc-technologies.co.jp/qa/QA-dev.html">http://www.hpc-technologies.co.jp/qa/QA-dev.html</a><br />
[3] <a href="http://club-hpc.com/index.php/Intel%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%83%BC">http://club-hpc.com/index.php/Intel%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%83%BC</a> (Fortranの移植性を参考)<br />
[4] <a href="http://webcache.googleusercontent.com/search?q=cache:910edLiiPoYJ:gfate.iobb.net/%7Ekawai/mv/fate/guidej.html+ifort+64bit+compile&amp;cd=25&amp;hl=ja&amp;ct=clnk&amp;gl=jp&amp;source=www.google.co.jp">http://webcache.googleusercontent.com/search?q=cache:910edLiiPoYJ:gfate.iobb.net/~kawai/mv/fate/guidej.html+ifort+64bit+compile&amp;cd=25&amp;hl=ja&amp;ct=clnk&amp;gl=jp&amp;source=www.google.co.jp</a><br />
[5] <a href="http://www2.kobe-u.ac.jp/%7Elerl2/usage_ifort90.html">http://www2.kobe-u.ac.jp/~lerl2/usage_ifort90.html</a><br />
[6] <a href="http://kekcc.kek.jp/service/cc/uguide/04.compile.html">http://kekcc.kek.jp/service/cc/uguide/04.compile.html</a><br />
[7] <a href="http://www.atmarkit.co.jp/flinux/rensai/linuxtips/537memulimit.html">http://www.atmarkit.co.jp/flinux/rensai/linuxtips/537memulimit.html</a><br />
[8] <a href="http://mvs.icc.ru/documentation/intel/f_ug1/ug1l_rt_errors.htm">http://mvs.icc.ru/documentation/intel/f_ug1/ug1l_rt_errors.htm</a><br />
[9] <a href="http://www.xlsoft.com/jp/products/intel/compilers/fcl/10.1/Release_Notes.htm">http://www.xlsoft.com/jp/products/intel/compilers/fcl/10.1/Release_Notes.htm</a><br />
[10] <a href="http://www.geocities.co.jp/Technopolis/4765/INTRO/parallel4.html">http://www.geocities.co.jp/Technopolis/4765/INTRO/parallel4.html</a><br />
[11] <a href="http://jp.xlsoft.com/documents/intel/compiler/527J-001.pdf">http://jp.xlsoft.com/documents/intel/compiler/527J-001.pdf</a><br />
[12] <a href="http://wwweic.eri.u-tokyo.ac.jp/computer/manual/altixuv/doc/Compiler/fort/jp_lnx_fortdocs11.1.tar/Documentation/ja_JP/compiler_f/main_for/optaps/common/optaps_par_openmp_using.htm">http://wwweic.eri.u-tokyo.ac.jp/computer/manual/altixuv/doc/Compiler/fort/jp_lnx_fortdocs11.1.tar/Documentation/ja_JP/compiler_f/main_for/optaps/common/optaps_par_openmp_using.htm</a> [13] <a href="http://wwweic.eri.u-tokyo.ac.jp/computer/manual/altixuv/doc/Compiler/fort/jp_lnx_fortdocs11.1.tar/Documentation/ja_JP/compiler_f/main_for/optaps/common/optaps_par_var.htm">http://wwweic.eri.u-tokyo.ac.jp/computer/manual/altixuv/doc/Compiler/fort/jp_lnx_fortdocs11.1.tar/Documentation/ja_JP/compiler_f/main_for/optaps/common/optaps_par_var.htm</a> [14] <a href="http://cs.nyu.edu/courses/fall10/G22.2945-001/slides/lect3-4.pdf">http://cs.nyu.edu/courses/fall10/G22.2945-001/slides/lect3-4.pdf</a><br />
--------------------------------------------------------------<br />
■ Linuxのファイル<br />
/usr/bin　：一般的なコマンドが格納されているファイル<br />
/usr/sbin ：システム管理コマンドが格納されているファイル<br />
/usr/local/bin　：ユーザーがコンパイルするなどしてインストールした一般的なコマンド<br />
/usr/local/sbin　：ユーザーがコンパイルするなどしてインストールした管理コマンド<br />
[1] <a href="http://heberekemaruhunihun.blog77.fc2.com/blog-entry-488.html">http://heberekemaruhunihun.blog77.fc2.com/blog-entry-488.html</a><br />
[2] <a href="http://what-linux.seesaa.net/article/140980754.html">http://what-linux.seesaa.net/article/140980754.html</a><br />
--------------------------------------------------------------<br />
■ 自作のプログラムをコマンド化する方法<br />
ln -s 自作プログラムのアドレス /usr/local/bin/自作プログラム動作のために名付けたいコマンド名<br />
--------------------------------------------------------------<br />
■ 目を通しておくべき文献<br />
[1] 伊理正夫、藤野和建、「数値計算の常識」、共立出版株式会社<br />
[2] 杉江日出澄ら、「FORTRAN 77 による数値計算法」、培風社<br />
[3] 森正武、「FORTRAN77数値計算プログラミング」、岩波書店<br />
[3] 渡部力ら、「Fortran77による数値計算ソフトウェア」、丸善<br />
[4] 小国力 訳、「LAPACK利用の手引」、丸善株式会社<br />
[5] 牛島省、「OpenMPによる並列プログラミングと数値計算法」、丸善<br />
--------------------------------------------------------------<br />
<br />
□ Makefile (Fortran)<br />
--------------------------------------------------------------<br />
FC = gfortran<br />
FFLAGS = -O2<br />
LIBS = -L/usr/lib -lblas -llapack -llapack95<br />
<br />
prog : main.o sub1.o<br />
$ (FC) $ (FFLAGS) -o prog main.o sub1.o $ (LIBS)<br />
main.o : main.f<br />
$ (FC) $ (FFLAGS) -c main.f<br />
sub1.o : sub.f<br />
$ (FC) $ (FFLAGS) -c sub1.f<br />
--------------------------------------------------------------<br />
-c : コンパイルのみ<br />
-o : 出力ファイルに名前を付ける<br />
-L : ライブラリの存在するディレクトリの指定<br />
-l : 使用するライブラリを指定（-l の後に、ライブラリの名称を記入）<br />
prog : やmain.o : の次の行にある$(FC)の前に TAB を入れておく必要がある。<br />
<br />
example (Makefile)<br />
--------------------------------------------------------------<br />
#FC= gfortran<br />
#FFLAGS= -Wall -pedantic -std=f95 -fbounds-check -O \<br />
#&nbsp; -Wuninitialized -ffpe-trap=invalid,zero,overflow -fbacktrace \<br />
#&nbsp; -g -free -m64<br />
FC=ifort<br />
FFLAGS= -O2<br />
#FFLAGS= -O2 -check all -warn all -std -fpe0 -traceback -g<br />
#LIBS = -L/usr/lib -lblas -llapack -llapack95<br />
#LIBS=<br />
#INCLUDE=<br />
#OBJS= makethhrklist.o makethhrinput.o calcthhr.o calcnfehr.o<br />
EXE= makethhrklist makethhrinput calcthhr calcnfehr<br />
<br />
all: makethhrklist makethhrinput calcthhr calcnfehr<br />
makethhrklist: makethhrklist.f90<br />
&nbsp;&nbsp; &nbsp;$(FC) $(FFLAGS) -o makethhrklist makethhrklist.f90<br />
#makethhrklist.o : makethhrklist.f90<br />
#&nbsp;&nbsp; &nbsp;$(FC) $(FFLAGS) -c makethhrklist.f90<br />
<br />
makethhrinput: makethhrinput.f90<br />
&nbsp;&nbsp; &nbsp;$(FC) $(FFLAGS) -o makethhrinput makethhrinput.f90<br />
#makethhrinput.o : makethhrinput.f90<br />
#&nbsp;&nbsp; &nbsp;$(FC) $(FFLAGS) -c makethhrinput.f90<br />
<br />
calcthhr: calcthhr.f90<br />
&nbsp;&nbsp; &nbsp;$(FC) $(FFLAGS) -o calcthhr calcthhr.f90<br />
#calcthhr.o : calcthhr.f90<br />
#&nbsp;&nbsp; &nbsp;$(FC) $(FFLAGS) -c calcthhr.f90<br />
<br />
calcnfehr: calcnfehr.f90<br />
&nbsp;&nbsp; &nbsp;$(FC) $(FFLAGS) -o calcnfehr calcnfehr.f90<br />
#calcnfehr.o : calcnfehr.f90<br />
#&nbsp;&nbsp; &nbsp;$(FC) $(FFLAGS) -c calcnfehr.f90<br />
<br />
clean:<br />
&nbsp;&nbsp; &nbsp; -rm -f $(EXE) *.o *.mod<br />
--------------------------------------------------------------<br />
Reference:<br />
<a href="http://d.hatena.ne.jp/cmphys/20120601/1338539221">http://d.hatena.ne.jp/cmphys/20120601/1338539221</a><br />
<a href="http://www.creatology.jp/unix/make.html">http://www.creatology.jp/unix/make.html</a><br />
--------------------------------------------------------------------------------<br />
■ C言語<br />
(編集中）<br />
<br />
参考文献<br />
[1] 益田 誠也 著、『0からはじめるプログラミングの基礎：C言語で作るプログラムの考え方』、テクノプレス、2002.<br />
[2] 宝剱 純一郎 著、『図解C言語プログラミングの仕組みと書き方：初心者でも必ずかわる本格的入門書』、メディア・テック出版、2002.<br />
[3] William H.Press 著、『ニューメリカルレシピ・イン・シー：C言語による数値計算のレシピ』、技術評論社、1993.<br />
[4] 日向 俊二 著、『C/C++プログラミング辞典：すぐに役立つ！』、翔泳社、2002.<br />
[5] 『NIKKEI SOFTWARE』、 2011年3月号<br />
[6] <a href="http://nlp.nagaokaut.ac.jp/C%E8%A8%80%E8%AA%9E%E5%85%A5%E9%96%80">http://nlp.nagaokaut.ac.jp/C%E8%A8%80%E8%AA%9E%E5%85%A5%E9%96%80</a><br />
[7] <a href="http://www.cis1.c.dendai.ac.jp/c_master/C_15.htm">http://www.cis1.c.dendai.ac.jp/c_master/C_15.htm</a><br />
[8] <a href="http://densan-labs.net/tech/clang">http://densan-labs.net/tech/clang</a><br />
[9] <a href="http://www.kumei.ne.jp/c_lang/">http://www.kumei.ne.jp/c_lang/</a><br />
[10] <a href="http://atom.rye.tama.ac.jp/%7Estock/cgengo/04ctext2/04ctext2.html">http://atom.rye.tama.ac.jp/~stock/cgengo/04ctext2/04ctext2.html</a><br />
[11] <a href="http://www.optic.or.jp/kaiseki-shien-net/0main-page/newpage2/mini-chishiki/mini-teramoto1.pdf">http://www.optic.or.jp/kaiseki-shien-net/0main-page/newpage2/mini-chishiki/mini-teramoto1.pdf</a>&nbsp;<br />
&nbsp; 4年くらい前だが、タンパク質を扱っている方（構造解析用の新しいプログラムを必要とするプロジェクトだと思う）がVisual C++を扱える博士号取得者が欲しいという求人を聞いたことがある。余裕があればVisual C++も勉強しておきたい。上記の参考文献の他に下記も参考にすると良いだろう。<br />
[12] 林晴比古、『Visual C++ 2005』、SofBank Creative.<br />
[13] 『Visual C++ 逆引き大全』、秀和システム<br />
[14] 日経ソフトウェア 2002年6月号<br />
<br />
□ Makefile (C言語)<br />
--------------------------------------------------------------<br />
CC = gcc<br />
CFLAGS = -O2<br />
LIBS = -lm<br />
<br />
prog : main.o sub1.o<br />
$ (CC) $ (CFLAGS) -o prog main.o sub1.o $ (LIBS)<br />
main.o : main.f<br />
$ (CC) $ (CFLAGS) -c main.c<br />
sub1.o : sub.f<br />
$ (CC) $ (CFLAGS) -c sub1.c<br />
--------------------------------------------------------------<br />
-c : コンパイルのみ<br />
-o : 出力ファイルに名前を付ける<br />
prog : やmain.o : の後の行はTABで始める必要がある<br />
--------------------------------------------------------------------------------<br />
■ バッチファイル(windows)<br />
<br />
□ case.bat<br />
--------------------------------------------------------------<br />
@echo off<br />
echo data transport<br />
if exist A.txt goto B<br />
:B<br />
&nbsp; copy A.txt C.txt<br />
&nbsp; echo copy A.txt to C.txt<br />
<br />
&nbsp; move A.txt D.txt<br />
<br />
&nbsp; echo&nbsp;end data &gt;&gt; D.txt<br />
<br />
&nbsp; del E.txt<br />
&nbsp; echo delete E.txt<br />
<br />
&nbsp; prog<br />
:end<br />
--------------------------------------------------------------<br />
&nbsp; 上記のバッチファイルはA.txtファイルが存在していたら、A.txtをC.txtにコピーして、A.txtをD.txtに変え、D.txtの最後に new dataと書き加え、E.txtを削除して、progというプログラムを動作させるものである。Fortranではwrite文でのFileの最後の読み 取りが上手くいかない場合があるので、このようにして最後の行を指定して処理することができる。<br />
このようなバッチファイルを使えば、Winmostarなどで得られたcase.xyzファイルを、他のプログラムで利用可能な入力ファイルに書き換えるなどが容易に出来るようになる。また、複数のプログラムを動作させたりすることも可能なので応用範囲は広い。<br />
<br />
--------------------------------------------------------------------------------<br />
■ C++<br />
(編集中）<br />
[1] <a href="http://www7b.biglobe.ne.jp/%7Erobe/cpphtml/">http://www7b.biglobe.ne.jp/~robe/cpphtml/</a><br />
[2] <a href="http://www7b.biglobe.ne.jp/%7Erobe/">http://www7b.biglobe.ne.jp/~robe/</a><br />
[3] ロベール、「ロベールのC++入門講座」、毎日コミュニケーションズ<br />
--------------------------------------------------------------------------------<br />
■ シェルスクリプト(Linux or Mac OS)<br />
<br />
□ bash<br />
--------------------------------------------------------------<br />
#! /bin/sh<br />
echo 'data transport'<br />
if [ ! -e&nbsp;A.txt ]; then<br />
&nbsp; echo 'not exist A.txt'<br />
fi<br />
<br />
cp A.txt to C.txt<br />
echo copy A.txt to C.txt<br />
<br />
mv A.txt D.txt<br />
<br />
rm&nbsp;E.txt<br />
echo&nbsp;remove E.txt<br />
<br />
prog<br />
--------------------------------------------------------------<br />
&nbsp; 上記のスクリプトはA.txtファイルが存在していたら、A.txtをC.txtにコピーして、A.txtをD.txtに変え、D.txtの最後にnew dataと書き加え、E.txtを削除して、progというプログラムを動作させるものである。<br />
<br />
□ cash<br />
--------------------------------------------------------------<br />
#! /bin/csh -f<br />
if !( -d SCF_DATA ) then<br />
&nbsp; mkdir SCF_DATA<br />
endif<br />
set file&nbsp;= `pwd`<br />
set file = $file:t<br />
set filename = $file'_scf_'<br />
if ( -e $filename.dos1eV ) then<br />
&nbsp;&nbsp;cp $filename.dos1eV ./SCF_DATA/$filename.dos_data<br />
endif<br />
if ( -e $filename.spaghetti&nbsp; ) then<br />
&nbsp; cp $filename.spaghetti&nbsp; ./SCF_DATA/$filename.band_data<br />
endif<br />
echo '-' &gt;&gt; ./SCF_DATA/$filename.dos_data<br />
prog<br />
--------------------------------------------------------------<br />
&nbsp; 上記のスクリプトはSCF_DATAフォルダが存在していなかったら、SCF_DATAフォルダを作成して、カレントディレクトリの名前を読み取り、それ に_scf_を付け加える。.dos1eVとspaghettiというファイルがあれば、SCF_DATAにカレントディレクトリの名前&nbsp;+ .dos_data及び.band_dataとしてそれぞれコピーする。そして、カレントディレクトリの名前 +&nbsp;.dos_dataの中身の最後の行に - を加えて、progというプログラムを動作させるものである。<br />
<br />
□ cash（調査中）<br />
--------------------------------------------------------------<br />
#! /bin/csh -f<br />
date<br />
pwd<br />
<br />
set XX=-FP<br />
set list=(&nbsp;1000000&nbsp;1010000&nbsp;11100000&nbsp;1111000&nbsp;1111100&nbsp;)<br />
echo $#list<br />
<br />
foreach No ( ${list} )<br />
echo ${No}<br />
&nbsp; if !( -e AAAA${XX}.ins) then<br />
&nbsp;&nbsp; &nbsp;echo &quot;AAAA&quot;${XX}&quot;.ins not exists&quot;<br />
&nbsp; else<br />
&nbsp;&nbsp;&nbsp; sed&nbsp;''${1 s/1110000/${No}/g' &quot;AAAA&quot;${XX}&quot;.ins &gt; new1.ins<br />
&nbsp;&nbsp;&nbsp;&nbsp;sed ''${2,3 s/1110000/${No}/g' new1.ins &gt; new2.ins<br />
&nbsp;&nbsp;&nbsp; object.exe<br />
&nbsp;&nbsp;&nbsp;&nbsp;sed ''${1 s/${No}/1110000/g' new2.ins &gt; new3.ins<br />
&nbsp;&nbsp;&nbsp; sed ''${2,3 s/${No}/1110000/g' new3.ins &gt; &quot;AAAA&quot;${XX}&quot;.ins<br />
&nbsp; endif<br />
end<br />
<br />
foreach No ( ${list} )<br />
echo ${No}<br />
&nbsp; grep &quot;Total Energy&quot; &quot;AAAA&quot;${XX}&quot;.ins | awk '{print $1}'<br />
end<br />
--------------------------------------------------------------<br />
[1] <a href="http://homepage3.nifty.com/tamekichi/cshell1.htm">http://homepage3.nifty.com/tamekichi/cshell1.htm</a><br />
[2] <a href="http://www.coins.tsukuba.ac.jp/%7Eyas/coins/syspro-2001/2001-06-25/">http://www.coins.tsukuba.ac.jp/~yas/coins/syspro-2001/2001-06-25/</a><br />
[3] <a href="http://d.hatena.ne.jp/bonlife/20060203/1138958036">http://d.hatena.ne.jp/bonlife/20060203/1138958036</a><br />
[4] <a href="http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1217798252">http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q1217798252</a><br />
<br />
--------------------------------------------------------------------------------<br />
■ Python<br />
　python（パイソン）の利点は、コンパイルが不要（確認中）なことである。FortranやC言語であれば、コンパイルの作業が必要になるので、 コードだけを渡しても手間が必要になり、プログラム未経験の人には小さな障害になりやすいが、pythonではその心配がない。引数は「ひきすう」と読 む。<br />
1. 文頭は下記のように記述する。sys,math はモジュールで標準ライブラリを使えるようにしている。「from numpy import *」は多次元配列を用いるために記述する。<br />
#!/usr/bin/python<br />
import sys,math<br />
from numpy import *<br />
2. 三次元配列の場合は、文献[4]を参考にすると良い。<br />
3. pythonはインデント(空白やTabの個数)でブロック（ifやfor, while文などの範囲）を分けている。<br />
<br />
Error [5]　（いまのところよく私が遭遇したエラー）<br />
1. SyntaxError: 多くの場合、クオーテーションや括弧の対応が取れていない場合やインデントが正しく行われていない。<br />
2. IndentationError: インデントが正しく行われていない。<br />
3. NameError: 未定義の変数（や関数、モジュール）などを参照または代入したときに表示される。<br />
4. IndexError: インデックスがリストの要素数に収まっていないときに表示される。<br />
5. ZeroDivisionError: 数値を0で割ろうとしたときに表示される。<br />
参考文献<br />
[1] 柏野 雄太、 小松 亮介、 穂苅 実紀夫 著、『実践python : 文字列操作からWebアプリケーション開発まで』、ディー・アート、2006.<br />
[2] <a href="http://d.hatena.ne.jp/dplusplus/20100126/p1">http://d.hatena.ne.jp/dplusplus/20100126/p1</a><br />
[3] <a href="http://d.hatena.ne.jp/niam/20110827">http://d.hatena.ne.jp/niam/20110827</a>&nbsp;<br />
　上記HPで危惧されているように、python 2.7 32bit 版を選択しないと、python 2.7 にリンクしてくれない。<br />
[4] python ３次元配列の作り方：<a href="http://pyansblog.blogspot.jp/2011/12/blog-post_05.html">http://pyansblog.blogspot.jp/2011/12/blog-post_05.html</a>&nbsp;<br />
[5] 柴田淳、「みんなのPython」、第3版、ソフトバンククリエイティブ<br />
--------------------------------------------------------------------------------<br />
■ Perl<br />
[1] <a href="http://d.hatena.ne.jp/perlcodesample/20091226/1264257759">http://d.hatena.ne.jp/perlcodesample/20091226/1264257759</a><br />
--------------------------------------------------------------------------------<br />
■ HTML<br />
&nbsp; 改行：<br />
( XHTML及びXMLでは<br />
)<br />
(編集中）<br />
--------------------------------------------------------------------------------<br />
■ wxWidgets<br />
(編集中）<br />
--------------------------------------------------------------------------------<br />
■ Excel VBA<br />
(編集中）<br />
[1] <a href="http://d.hatena.ne.jp/nattou_curry_2/20100129/1264787849">http://d.hatena.ne.jp/nattou_curry_2/20100129/1264787849</a><br />
[2] <a href="http://excelvba.pc-users.net/">http://excelvba.pc-users.net/</a><br />
[3] <a href="http://www.asahi-net.or.jp/%7Ezn3y-ngi/YNxv239.html">http://www.asahi-net.or.jp/~zn3y-ngi/YNxv239.html</a><br />
[4] <a href="http://www.eurus.dti.ne.jp/yoneyama/Excel/Exl-_zen.htm">http://www.eurus.dti.ne.jp/yoneyama/Excel/Exl-_zen.htm</a><br />
--------------------------------------------------------------------------------<br />
■ LabVIEW<br />
&nbsp; 無料のセミナーが開催されているので参加すると良い。データ取得用の装置は性能によるが、最低2-3万円程度で購入できる。また、デモ機も貸し出しているので交渉してみると良い。成功すれば教官にもっとよいものを購入してもらおう。<br />
&nbsp; 無料のセミナーでは、取得している間のデータをグラフで表示でき、測定終了後に結果をtxtやcsv形式で保存する方法が容易に覚えられる。Excelでは途中でグラフが表示できないものでもLabVIEWだと可能にできる。<br />
--------------------------------------------------------------------------------<br />
■ Igor （基礎編）<br />
□ グラフの大きさの固定<br />
1) グラフを二回クリックする。<br />
2) 余白に値を入力。幅モードと縦モードを固定幅にして値を入力する。<br />
3) グラフの設定を保存する（とりあえず全部にチェックを入れておけばよいだろう）。<br />
□&nbsp;グラフの修正<br />
1) 縦軸を二回クリックする。<br />
2) 「軸」<br />
&nbsp; a)&nbsp;「離す」のチェックを外す。<br />
&nbsp;&nbsp;b) 「反対」をオン。<br />
&nbsp;&nbsp;c)&nbsp;「フォント」を Arial にする。<br />
&nbsp;&nbsp;d) フォントのサイズを 14&nbsp;? 16 程度にする。<br />
3) 「目盛とグリッド」<br />
&nbsp;&nbsp;a)&nbsp;「位置：」を内側にする。<br />
4) 「軸ラベル」<br />
&nbsp;&nbsp;&nbsp; Intensity / arb. units など、必要な事項を入力する。<br />
5) 以上を横軸に対しても同様に行う。<br />
□ コマンドウインドウ（「名称未設定」など）に式を入れると簡単な計算が可能になる。<br />
a) A := B + C とすると、 従属関係が構築され、BやCの値を変えると、自動的に A の値が変わるようになる。<br />
b) 電卓として用いたい場合は、コマンドウインドウ（「名称未設定」など）で、print と入力した後に、式を入力する。例 print 25*40<br />
c) 全ての行った行動は、コマンドウインドウに表示される。これをコピー&amp;ペーストすると別のグラフでもほとんどのコマンドが同じように動作する。<br />
--------------------------------------------------------------------------------<br />
■ Igor macro（基礎編）<br />
1) 「データ（D)」&rarr;「Data Browser」<br />
2) 「Data Browser」にて、「New Folder...」で新しい名称のファイルを作成する。<br />
3) 右側にある矢印を好きなフォルダに移動させる。<br />
4) 「Browse Expt...」を押して、過去に作成したファイルを開く。<br />
5) 右側に過去に作成したファイルのデータがあるので、必要なものを左側に移動させる。<br />
6) よく使うコマンドは、コマンドウインドウ（「名称未設定」など）に表示される。ここで、赤線の上の部分で必要なものをメモ帳やプロシージャなどにコピーしておいて、赤線の下にペーストすれば、同じ動作を簡単に行うことができる。<br />
--------------------------------------------------------------------------------<br />
■ Igor macro（初級編）<br />
1) 「ウインドウ（W）」&rarr;「新規（N）」&rarr;「パネル（A）」<br />
2) Panel0 を右クリックして「背景をコントロール」を選択し、好きな色に変えることができる。<br />
3) 「パネル（P）」&rarr;「コントロールを追加（A）」&rarr;「ボタンを追加（B）」<br />
4) 「パネル（P）」&rarr;「ツールを表示（T）」<br />
&nbsp; a) 左側の二番目を選択し、上記3)で作成したボタンなどをクリックして好きな場所に移動。<br />
&nbsp; b) 二回クリックすると編集ができる。新規プロシージャを作成する。<br />
&nbsp; c) パネルを利用するタイプのものに戻す場合は、左側の一番目を押す。<br />
5) 通常良く使う動作を行って、（基礎編）で勉強したように、コマンドをメモっておく。<br />
6) 「ウインドウ（W）」&rarr;「プロシージャウィンドウ（P）」にて、よく使うコマンドをコピー&amp;ペーストする。<br />
7) ボタンを押せば動作する。<br />
--------------------------------------------------------------------------------<br />
■ Igor macro（中級編）<br />
下記を参考にするのがよい。大事なこととして、Igorはコマンドラインの合計の長さが400文字に制限されており、行継続記号が無い。<br />
<a href="http://www.ppl.k.u-tokyo.ac.jp/saito/etc.html">http://www.ppl.k.u-tokyo.ac.jp/saito/etc.html</a><br />
<a href="http://www.nips.ac.jp/huinfo/documents/IGOR/igor01.html">http://www.nips.ac.jp/huinfo/documents/IGOR/igor01.html</a><br />
<a href="http://nps.sakura.ne.jp/sf/Igor/Igor1.htm">http://nps.sakura.ne.jp/sf/Igor/Igor1.htm</a><br />
<a href="http://www.pme.kit.ac.jp/annex/archives/igor_pro/">http://www.pme.kit.ac.jp/annex/archives/igor_pro/</a><br />
<a href="http://www.cm.kj.yamagata-u.ac.jp/atom11archive/res/mac/mes/igor_ni.html">http://www.cm.kj.yamagata-u.ac.jp/atom11archive/res/mac/mes/igor_ni.html</a><br />
<a href="http://www.hulinks.co.jp/support/igor/index.html">http://www.hulinks.co.jp/support/igor/index.html</a>　<br />
<a href="http://burggarten.ddo.jp/%7Etomo/blog/?p=1019">http://burggarten.ddo.jp/~tomo/blog/?p=1019</a><br />
<a href="http://payam.minoofar.com/igor/">http://payam.minoofar.com/igor/</a><br />
<a href="http://geo.shunpike.info/jpsj/06702/067020038.pdf">http://geo.shunpike.info/jpsj/06702/067020038.pdf</a><br />
<a href="http://dora.bk.tsukuba.ac.jp/%7Etakeuchi/index.php?%A5%BD%A5%D5%A5%C8%A5%A6%A5%A7%A5%A2%2FIgor%2F%A5%B7%A5%B9%A5%C6%A5%E0%A4%CE%B4%F0%CB%DC">http://dora.bk.tsukuba.ac.jp/~takeuchi/index.php?%A5%BD%A5%D5%A5%C8%A5%A6%A5%A7%A5%A2%2FIgor%2F%A5%B7%A5%B9%A5%C6%A5%E0%A4%CE%B4%F0%CB%DC</a><br />
<a href="http://mikaka.org/%7Ekana/dl/pdf/pdf-igor.pdf">http://mikaka.org/~kana/dl/pdf/pdf-igor.pdf</a><br />
<br />
Mac の場合は下記のHPを参照すると良い。LEEDやRHEEDを行う学生も目を通しておくと良い。<br />
<a href="http://surfphys.tagen.tohoku.ac.jp/pages/HowToUseIgor/HowToUseIgor.pdf">http://surfphys.tagen.tohoku.ac.jp/pages/HowToUseIgor/HowToUseIgor.pdf</a><br />
粉末X線回折の場合は下記HPを参照すると良い。<br />
<a href="http://www.crl.nitech.ac.jp/%7Eida/index-j.html">http://www.crl.nitech.ac.jp/~ida/index-j.html</a><br />
画像の処理では下記が参考になる。<br />
<a href="http://dora.bk.tsukuba.ac.jp/%7Etakeuchi/index.php?%A5%BD%A5%D5%A5%C8%A5%A6%A5%A7%A5%A2%2FIgor%2F%A5%B0%A5%E9%A5%D5%B4%D8%CF%A2">http://dora.bk.tsukuba.ac.jp/~takeuchi/index.php?%A5%BD%A5%D5%A5%C8%A5%A6%A5%A7%A5%A2%2FIgor%2F%A5%B0%A5%E9%A5%D5%B4%D8%CF%A2</a><br />
<br />
□ Table表示<br />
---------------------------------------------------<br />
Macro&nbsp;xxxxx()<br />
&nbsp; Make/T/O&nbsp;text&nbsp;&nbsp; &nbsp;// define a text data<br />
&nbsp; Make/O wave&nbsp;&nbsp;&nbsp; // define a wave data<br />
&nbsp;&nbsp;text[0] =&nbsp;&quot;First data&quot;<br />
&nbsp; text[1] =&nbsp;&quot;Second data&quot;<br />
&nbsp; wave[0] = 100<br />
&nbsp; wave[1] =&nbsp;200<br />
&nbsp; Edit text, wave&nbsp;&nbsp; &nbsp;// show a table<br />
EndMacro<br />
---------------------------------------------------<br />
&nbsp;&nbsp; 上記は、マクロ(M)の中にxxxxx という名称のマクロが出来る。Make/T でテキストを、Makeでウェーブを定義して、その具体的な値をwave[0]=100 などで指定している。これらのMakeの後の/Oは上書きの意味。Editは表を示す。このマクロを利用すると、常に初期値を表として出力できるようにな る。フィッティングやデータのメモとして利用できる。<br />
<br />
□ データを受け渡して処理するマクロ<br />
---------------------------------------------------<br />
Macro xxxxx( var1, var2 )<br />
&nbsp; Variable var1, var2<br />
&nbsp;&nbsp;Prompt var1, &quot;Enter the First&nbsp;data number (1&lt; var1 &lt;=99)&quot;<br />
&nbsp;&nbsp;Prompt var2, &quot;Enter the Last &nbsp;data number (2&lt;&nbsp;var2 &lt;= 100)&quot;<br />
&nbsp; Make/N=100/O&nbsp;sign_data&nbsp;&nbsp; &nbsp;// define a wave data<br />
&nbsp;&nbsp;Make/N=100/O BG_data&nbsp;&nbsp; &nbsp;// define a wave data<br />
&nbsp;&nbsp;&nbsp; calculation( var1, var2, sign_data,&nbsp;BG_data&nbsp;)<br />
&nbsp; Edit sign_data, &nbsp;BG_data&nbsp;&nbsp; // show a table<br />
EndMacro<br />
<br />
Funciton calculation( var1, var2, sign_data,&nbsp;BG_data&nbsp;)<br />
&nbsp; Variable var1, var2<br />
&nbsp; Variable i, k_first, k_last, BG_sum_data<br />
&nbsp; Wave sign_data, BG_data<br />
&nbsp;&nbsp;k_last = 0.2<br />
&nbsp;&nbsp;do<br />
k_first&nbsp;= k_last<br />
&nbsp;&nbsp;&nbsp; BG_sum_data = 0<br />
&nbsp;&nbsp;&nbsp; for ( i=var1; i&lt;=var2; i&nbsp;+=1 )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BG_data[i]&nbsp;= k_first*&nbsp;(sign_data[i] - sign_data[var1] - BG_data[i])<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BG_sum_data += BG_data[i]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BG_data[i] =&nbsp;BG_sum_data<br />
&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp;&nbsp; &nbsp;k_last = k_first * (sign_data[var2] - sing_data[var1]) / BG_data[var2]<br />
&nbsp;&nbsp;while( abs( k_first - k_last ) &gt;0.0001 )<br />
&nbsp; return sign_data<br />
&nbsp; return&nbsp;BG_data<br />
End<br />
---------------------------------------------------<br />
&nbsp; 上記のMacroではVariableでver1とver2が数値変数であると宣言しています。次に、ver1とver2に数値を入れるようにさせ、 Functionによってユーザー側で定義した下記にある関数calculationに移ります。関数内で必要となる数値変数とウェーブをそれぞれ VariableとWaveで定義しています。k_last=0.2とBG_sum_data=0で初期の値を設定しています。do?while間は whileの後の()の中が真のとき繰り返されます。その中にabs()とあるのは、()の値を絶対値にするという意味です。つまり、(k_first - k_last)の絶対値が0.0001を超えている間はdo?while間を繰り返すという意味になります。次のfor?endfor間は、初めにiを var1にし、for?endfor間を繰り返す毎にiを1ずつ足していき（i += x はi = i&nbsp;+ 1と同じ意味）、iがver2を超えるまで繰り返すことを指定しています。さらにその中では、sign_data [i]からsing_data[var1]とBG_data[i]を引いた結果にk_firstを掛けて、新しいBG_data[i]としています。次に BG_sum_dataにBG_dataの値を加算し、BG_data[i]にこれまで加算されてきたBG_sum_dataの値が入れられます。 for?endforの繰り返しが終わるとvar2番目のデータと比較し、k_lastの値を調節します。do?whileを抜けると、Macroに sing_dataとBG_dataの値を返します。最後に、結果が表として出力されます。<br />
上記を参考にすれば、XPSなどでのデータでBGを差し引くマクロを作成することができます。これらは学部3?4年生が数週間程度で行う課題に丁度良いでしょう。<br />
---------------------------------------------------<br />
<br />
□ 複数のデータがある場合の一括処理のさせ方<br />
---------------------------------------------------<br />
Macro Series_Analysis (&nbsp;First_wave_number, Last_wave_number )<br />
&nbsp; Variable First_wave_number = 0&nbsp;&nbsp;&nbsp; // Set a initial data<br />
&nbsp; Variable Last_wave_number = 21&nbsp; // Set a initial data<br />
&nbsp; Prompt First_wave_number, &quot;Enter the First wave number&quot;&nbsp; &nbsp;// Input data<br />
&nbsp; Prompt Last_wave_number, &quot;Enter the Last wave number&quot;&nbsp;&nbsp; // Input data<br />
&nbsp;&nbsp;Make/N=100/O&nbsp;sign_data&nbsp;&nbsp; // Make a wave data<br />
&nbsp; Make/N=100/O BG_data&nbsp;&nbsp; // Make a wave data<br />
&nbsp; Variable var1, var2<br />
&nbsp; Prompt var1, &quot;Enter the First data number (1&lt; var1 &lt;=99)&quot;&nbsp;&nbsp;&nbsp; // Input data<br />
&nbsp; Prompt var2, &quot;Enter the Last data number (2&lt; var2 &lt;= 100)&quot;&nbsp;&nbsp;&nbsp; // Input data<br />
&nbsp; Series_calculation( First_wave_number, Last_wave_number, var1, var2, sign_data,&nbsp;BG_data&nbsp;)<br />
&nbsp; Edit sign_data, BG_data&nbsp;&nbsp;&nbsp; // Edit a table<br />
EndMacro<br />
<br />
Function Series_calculation( First_wave_number, Last_wave_number, var1, var2, sign_data, BG_data )<br />
&nbsp; Variable i, var1, var2<br />
Wave&nbsp;sign_data, BG_data&nbsp;<br />
&nbsp;&nbsp;String sign_wave_name, BG_wave_name<br />
&nbsp; for( i= First_wave_number; i &lt;= Last_wave_number ; i&nbsp;+= 2 )<br />
&nbsp;&nbsp;&nbsp;&nbsp;sing_wave_name = &quot;wave&quot; + num2istr(i)<br />
&nbsp;&nbsp;&nbsp; BG_wave_name = &quot;wave&quot; + num2istr(i+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;calculate( var1, var2, sign_wave_name, BG_wave_name&nbsp;)<br />
&nbsp;&nbsp;&nbsp;&nbsp;Display $sign_wave_name, $BG_wave_name&nbsp;&nbsp;&nbsp; // Edit graph<br />
&nbsp; Endfor<br />
End<br />
---------------------------------------------------<br />
&nbsp; 上記は、wave1から順にデータを取り込んで、処理していくマクロになる。上記までを参考にすれば、様々なデータを連続的に処理することができるだろ う。ちなみに、x軸のデータがある場合は、Display&nbsp;y軸方向のwave名 vs x軸方向のwave名 で表示させることができる。複製はDuplicate文があるのでそれらも活用するとよい。<br />
<br />
□ BoltzTraPからのcase.traceから 特定の温度ときのゼーベック係数と化学ポテンシャルに対するグラフを描画するマクロ<br />
---------------------------------------------------</p>

<p>#pragma rtGlobals=1&nbsp;&nbsp;// Use modern global access method.<br />
// ver.1.10</p>

<p>Macro seebeck_panel()</p>

<p>NewPanel/W=(0, 0, 180, 190)</p>

<p>Button button0 proc=ButtonProc_1<br />
Button button0 title=&quot;change name&quot;,proc=ButtonProc_1<br />
SetDrawEnv fsize= 14<br />
Button button0 size={150,20}<br />
Button button0 pos={15,3}</p>

<p>SetVariable setvar0 proc=SetVarProc,limits={-inf,inf,0},fSize=14<br />
SetVariable setvar0 value= _NUM:0<br />
SetVariable setvar0 size={70,20}<br />
SetVariable setvar0 pos={55,30}</p>

<p>DrawText 25,45,&quot;Ef =&quot;<br />
SetDrawEnv fsize= 14</p>

<p>DrawText 130,45,&quot;Ry&quot;<br />
SetDrawEnv fsize= 14</p>

<p>PopupMenu popup0 proc=PopMenuProc<br />
PopupMenu popup0 value=&quot;50;100;150;200;250;300;350;400;450;500;550;600;650;700;750;800;850;900;950;1000&quot;<br />
PopupMenu popup0 fSize=14<br />
PopupMenu popup0 pos={120,55}</p>

<p>DrawText 15,70,&quot;Temperature [K]&quot;<br />
SetDrawEnv fsize= 14</p>

<p>Button button1 title=&quot;S - &mu; relation&quot;,proc=ButtonProc<br />
SetDrawEnv fsize= 14<br />
Button button1 size={100,30}<br />
Button button1 pos={60,80}</p>

<p>Button button2 title=&quot;series&quot;,proc=ButtonProc_2<br />
SetDrawEnv fsize= 14<br />
Button button2 size={150,20}<br />
Button button2 pos={15,115}</p>

<p>SetDrawEnv fsize= 14<br />
DrawText 25,155,&quot;&mu; =&quot;</p>

<p>SetVariable setvar1 proc=SetVarProc_1,limits={-inf,inf,0}<br />
SetVariable setvar1 value= _NUM:0<br />
SetVariable setvar1 size={50,15}<br />
SetVariable setvar1 pos={60,140}</p>

<p>Button button3 title=&quot;plot&quot;,proc=ButtonProc_3<br />
Button button3 size={50,20}<br />
Button button3 pos={115,138}</p>

<p>Button button4 proc=ButtonProc_4<br />
Button button4 title=&quot;series plot&quot;<br />
Button button4 size={70,20}<br />
Button button4 pos={55,165}<br />
Button button4 fSize=14</p>

<p>End</p>

<p>// convert Ry to eV and change name<br />
Function ButtonProc_1(ba) : ButtonControl<br />
&nbsp;STRUCT WMButtonAction &amp;ba</p>

<p>&nbsp;switch( ba.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;// click code here<br />
&nbsp;&nbsp;&nbsp;WAVE wave0, wave1, wave2, wave3, wave4, wave5, wave6, wave7, wave8, wave9<br />
&nbsp;&nbsp;&nbsp;// rename<br />
&nbsp;&nbsp;&nbsp;Rename wave0,Ef_Ry; Rename wave1,T_K; Rename wave2,N; Rename wave3,DOS_Ef<br />
&nbsp;&nbsp;&nbsp;Rename wave4,Seebeck; Rename wave5,S_t; Rename wave6,R_H; Rename wave7,kappa0<br />
&nbsp;&nbsp;&nbsp;Rename wave8,c; Rename wave9,chi<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch</p>

<p>&nbsp;return 0<br />
End</p>

<p>// read non_dope_EF<br />
Function SetVarProc(sva) : SetVariableControl<br />
&nbsp;STRUCT WMSetVariableAction &amp;sva</p>

<p>&nbsp;switch( sva.eventCode )<br />
&nbsp;&nbsp;case 1: // mouse up<br />
&nbsp;&nbsp;case 2: // Enter key<br />
&nbsp;&nbsp;case 3: // Live update<br />
&nbsp;&nbsp;&nbsp;Variable dval = sva.dval<br />
&nbsp;&nbsp;&nbsp;String sval = sva.sval<br />
&nbsp;&nbsp;&nbsp;Variable/G Ef_non_dope<br />
&nbsp;&nbsp;&nbsp;Variable Num_of_Wave<br />
&nbsp;&nbsp;&nbsp;WAVE Ef_Ry<br />
&nbsp;&nbsp;&nbsp;Num_of_Wave = DimSize(Ef_Ry,0)<br />
&nbsp;&nbsp;&nbsp;Make/O/N=(Num_of_Wave) Ef_eV<br />
&nbsp;&nbsp;&nbsp;Ef_non_dope = dval<br />
&nbsp;&nbsp;&nbsp;Ef_eV = (Ef_Ry - Ef_non_dope)*13.602<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch</p>

<p>&nbsp;return 0<br />
End</p>

<p>// set extacting temperature<br />
Function PopMenuProc(pa) : PopupMenuControl<br />
&nbsp;STRUCT WMPopupAction &amp;pa</p>

<p>&nbsp;switch( pa.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;Variable popNum = pa.popNum<br />
&nbsp;&nbsp;&nbsp;String popStr = pa.popStr<br />
&nbsp;&nbsp;&nbsp;Variable/G temp<br />
&nbsp;&nbsp;&nbsp;temp = str2num (popStr)<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch</p>

<p>&nbsp;return 0<br />
End</p>

<p><br />
// run bottun<br />
Function ButtonProc(ba) : ButtonControl<br />
&nbsp;STRUCT WMButtonAction &amp;ba</p>

<p>&nbsp;switch( ba.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;// click code here<br />
&nbsp;&nbsp;&nbsp;NVAR temp<br />
&nbsp;&nbsp;&nbsp;print&nbsp; &quot;extract the&quot;, temp,&quot;K data from the case.trace&quot;<br />
&nbsp;&nbsp;&nbsp;sub_extract(temp)<br />
&nbsp;&nbsp;&nbsp;ModifyGraph width=0,height=0<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch</p>

<p>&nbsp;return 0<br />
End</p>

<p><br />
// main routine<br />
Function sub_extract(temp_K)<br />
&nbsp; Variable temp_K<br />
&nbsp; WAVE Ef_eV, T_K, N, DOS_Ef, Seebeck, S_t, R_H, kappa0, c, chi<br />
&nbsp;<br />
&nbsp; Variable Num_of_Wave, i, j<br />
&nbsp; Num_of_Wave = DimSize(T_K,0)<br />
&nbsp; Make/N=(Num_of_Wave) Shifted_Ef_tempo, Seebeck_at_Shifted_Ef_tempo<br />
&nbsp;<br />
&nbsp; i = 0; j = 0<br />
&nbsp; do<br />
&nbsp;&nbsp;&nbsp; if ( T_K[i] == temp_K )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shifted_Ef_tempo[j] = Ef_eV[i]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seebeck_at_Shifted_Ef_tempo[j] = Seebeck[i]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = j + 1<br />
&nbsp;&nbsp;&nbsp; endif<br />
&nbsp;&nbsp;&nbsp; i = i +1<br />
&nbsp; while ( i &lt; DimSize(T_K,0) )<br />
&nbsp;<br />
&nbsp; String name_of_wave<br />
&nbsp; name_of_wave =&nbsp; &quot;Seebeck_at_&quot; + num2str(temp_K) + &quot;_K&quot;<br />
&nbsp; Make/O/N=(j) Shifted_Ef, $name_of_wave<br />
&nbsp; Wave Seebeck_at_Shifted_Ef = $name_of_wave</p>

<p>&nbsp; Shifted_Ef = Shifted_Ef_tempo<br />
&nbsp; Seebeck_at_Shifted_Ef = Seebeck_at_Shifted_Ef_tempo * 10^6<br />
&nbsp;<br />
&nbsp; Display&nbsp; Seebeck_at_Shifted_Ef vs Shifted_Ef<br />
&nbsp;<br />
&nbsp; //setting graph<br />
&nbsp; ModifyGraph tick=2,mirror=1,fSize=14,standoff=0,font=&quot;Arial&quot;<br />
&nbsp; Label left &quot;<a>\\Z14\rSeebeck</a> coefficients / <a>\\F'Symbol'm\\F'Arial'V</a>必<a>\\S-1</a>&quot;<br />
&nbsp; ModifyGraph tick(bottom)=2,mirror(bottom)=1,fSize(bottom)=14,standoff(bottom)=0<br />
&nbsp; ModifyGraph font(bottom)=&quot;Arial&quot;<br />
&nbsp; Label bottom &quot;<a>\\Z14\\F'Symbol'm\\F'Arial'</a> / eV&quot;<br />
&nbsp; SetAxis bottom -2,2<br />
&nbsp; ModifyGraph margin(left)=57<br />
&nbsp; ModifyGraph margin(bottom)=43<br />
&nbsp; ModifyGraph width=340.157,height=226.772<br />
&nbsp; Legend/C/N=text0/F=0/B=1/A=MC/X=30.00/Y=40.00<br />
&nbsp;<br />
&nbsp; KillWaves Shifted_Ef_tempo, Seebeck_at_Shifted_Ef_tempo<br />
&nbsp;<br />
End</p>

<p>// series<br />
Function ButtonProc_2(ba) : ButtonControl<br />
&nbsp;STRUCT WMButtonAction &amp;ba</p>

<p>&nbsp;switch( ba.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;// click code here<br />
&nbsp;&nbsp;&nbsp;&nbsp; Variable temp_K<br />
&nbsp;&nbsp;&nbsp;&nbsp; temp_K = 100<br />
&nbsp;&nbsp;&nbsp;&nbsp; sub_extract(temp_K)<br />
&nbsp;&nbsp;&nbsp;&nbsp; for ( temp_K=200; temp_K&lt;=800; temp_K+=100)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub2_extract(temp_K)<br />
&nbsp;&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp;&nbsp;&nbsp;&nbsp; ModifyGraph rgb(Seebeck_at_200_K)=(65280,21760,0)<br />
&nbsp;&nbsp;&nbsp;&nbsp; ModifyGraph rgb(Seebeck_at_400_K)=(40960,65280,16384)<br />
&nbsp;&nbsp;&nbsp;&nbsp; ModifyGraph rgb(Seebeck_at_500_K)=(0,52224,0)<br />
&nbsp;&nbsp;&nbsp;&nbsp; ModifyGraph rgb(Seebeck_at_600_K)=(0,65280,65280)<br />
&nbsp;&nbsp;&nbsp;&nbsp; ModifyGraph rgb(Seebeck_at_700_K)=(0,0,65280)<br />
&nbsp;&nbsp;&nbsp;&nbsp; ModifyGraph rgb(Seebeck_at_800_K)=(29440,0,58880)<br />
&nbsp;&nbsp;&nbsp;&nbsp; Legend/C/N=text0/F=0/B=1/A=MC/X=30.00/Y=25.00<br />
&nbsp;&nbsp;&nbsp;&nbsp; ModifyGraph width=0,height=0<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch</p>

<p>&nbsp;return 0<br />
End</p>

<p>//second main<br />
Function sub2_extract(temp_K)<br />
&nbsp; Variable temp_K<br />
&nbsp; WAVE Ef_eV, T_K, N, DOS_Ef, Seebeck, S_t, R_H, kappa0, c, chi<br />
&nbsp;<br />
&nbsp; Variable Num_of_Wave, i, j<br />
&nbsp; Num_of_Wave = DimSize(T_K,0)<br />
&nbsp; Make/N=(Num_of_Wave) Shifted_Ef_tempo, Seebeck_at_Shifted_Ef_tempo<br />
&nbsp;<br />
&nbsp; i = 0; j = 0<br />
&nbsp; do<br />
&nbsp;&nbsp;&nbsp; if ( T_K[i] == temp_K )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shifted_Ef_tempo[j] = Ef_eV[i]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seebeck_at_Shifted_Ef_tempo[j] = Seebeck[i]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = j + 1<br />
&nbsp;&nbsp;&nbsp; endif<br />
&nbsp;&nbsp;&nbsp; i = i +1<br />
&nbsp; while ( i &lt; DimSize(T_K,0) )<br />
&nbsp;<br />
&nbsp; String name_of_wave<br />
&nbsp; name_of_wave =&nbsp; &quot;Seebeck_at_&quot; + num2str(temp_K) + &quot;_K&quot;<br />
&nbsp; Make/O/N=(j) Shifted_Ef, $name_of_wave<br />
&nbsp; Wave Seebeck_at_Shifted_Ef = $name_of_wave</p>

<p>&nbsp; Shifted_Ef = Shifted_Ef_tempo<br />
&nbsp; Seebeck_at_Shifted_Ef = Seebeck_at_Shifted_Ef_tempo * 10^6<br />
&nbsp;<br />
&nbsp; AppendToGraph&nbsp; Seebeck_at_Shifted_Ef vs Shifted_Ef<br />
&nbsp;<br />
&nbsp; KillWaves Shifted_Ef_tempo, Seebeck_at_Shifted_Ef_tempo<br />
End</p>

<p>//<br />
Function SetVarProc_1(sva) : SetVariableControl<br />
&nbsp;STRUCT WMSetVariableAction &amp;sva</p>

<p>&nbsp;switch( sva.eventCode )<br />
&nbsp;&nbsp;case 1: // mouse up<br />
&nbsp;&nbsp;case 2: // Enter key<br />
&nbsp;&nbsp;case 3: // Live update<br />
&nbsp;&nbsp;&nbsp;Variable dval = sva.dval<br />
&nbsp;&nbsp;&nbsp;String sval = sva.sval<br />
&nbsp;&nbsp;&nbsp;Variable/G mu =&nbsp; dval<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch</p>

<p>&nbsp;return 0<br />
End</p>

<p>// S - K plot<br />
Function ButtonProc_3(ba) : ButtonControl<br />
&nbsp;STRUCT WMButtonAction &amp;ba</p>

<p>&nbsp;switch( ba.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;// click code here<br />
&nbsp;&nbsp;&nbsp;NVAR mu<br />
&nbsp;&nbsp;&nbsp;sub3_extract(mu)<br />
&nbsp;&nbsp;&nbsp;ModifyGraph width=0,height=0<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch</p>

<p>&nbsp;return 0<br />
End</p>

<p>//third main<br />
Function sub3_extract(mu)<br />
&nbsp; Variable mu<br />
&nbsp; WAVE Ef_eV, T_K, N, DOS_Ef, Seebeck, S_t, R_H, kappa0, c, chi<br />
&nbsp;<br />
&nbsp; Variable Num_of_Wave, i, j, k, num_of_temp<br />
&nbsp; Variable mu_low, mu_high<br />
&nbsp; Num_of_Wave = DimSize(T_K,0)<br />
&nbsp; Make/N=(Num_of_Wave) K_tempo, Seebeck_for_K_tempo<br />
&nbsp;<br />
&nbsp; i = 0; j = 0; k = 0<br />
&nbsp; do<br />
&nbsp;&nbsp;&nbsp; if ( Ef_eV[i] &lt;= mu &amp;&amp; mu &lt;= Ef_eV[i+1] )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mu_low = Ef_eV[i]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mu_high = Ef_eV[i+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = k + 1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( T_K[i-k] &lt; T_K[i-k+1] )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_of_temp = k<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(k=0;k &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; K_tempo[k] = T_K[i+k+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seebeck_for_K_tempo[k] = (Seebeck[i+k+1] - Seebeck[i-num_of_temp+k+1]) * (mu - mu_low) / ( mu_high - mu_low ) +&nbsp; Seebeck[i-num_of_temp+k+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //print&nbsp; T_K[i+k+1], T_K[i-num_of_temp+k+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //print&nbsp; Seebeck[i+k+1], Seebeck[i-num_of_temp+k+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br />
&nbsp;&nbsp;&nbsp; endif<br />
&nbsp;&nbsp;&nbsp; i = i +1<br />
&nbsp; while ( i &lt; (DimSize(T_K,0) -1) )<br />
&nbsp;<br />
&nbsp; String name_of_wave<br />
&nbsp; name_of_wave = &quot;Seebeck_at_&quot; + num2str(mu) + &quot;_eV&quot;<br />
&nbsp; Make/O/N=(num_of_temp) temp_K, $name_of_wave<br />
&nbsp; Wave Seebeck_for_K = $name_of_wave</p>

<p>&nbsp; temp_K = K_tempo<br />
&nbsp; Seebeck_for_K = Seebeck_for_K_tempo * 10^6<br />
&nbsp;<br />
&nbsp; Display&nbsp; Seebeck_for_K vs temp_K<br />
&nbsp;<br />
&nbsp; //setting graph<br />
&nbsp; ModifyGraph mode=4,marker=19,msize=4<br />
&nbsp; ModifyGraph tick=2,mirror=1,fSize=14,standoff=0,font=&quot;Arial&quot;<br />
&nbsp; Label left &quot;<a>\\Z14\rSeebeck</a> coefficients / <a>\\F'Symbol'm\\F'Arial'V</a>必<a>\\S-1</a>&quot;<br />
&nbsp; ModifyGraph tick(bottom)=2,mirror(bottom)=1,fSize(bottom)=14,standoff(bottom)=0<br />
&nbsp; ModifyGraph font(bottom)=&quot;Arial&quot;<br />
&nbsp; Label bottom &quot;<a>\\Z14\\F'Arial'Temperature</a> / K&quot;<br />
&nbsp; SetAxis bottom 50,800<br />
&nbsp; ModifyGraph margin(left)=57<br />
&nbsp; ModifyGraph margin(bottom)=43<br />
&nbsp; ModifyGraph width=340.157,height=226.772<br />
&nbsp; Legend/C/N=text0/F=0/B=1/A=MC/X=30.00/Y=40.00<br />
&nbsp;<br />
&nbsp; KillWaves K_tempo, Seebeck_for_K_tempo<br />
&nbsp;<br />
End</p>

<p>Function ButtonProc_4(ba) : ButtonControl<br />
&nbsp;STRUCT WMButtonAction &amp;ba</p>

<p>&nbsp;switch( ba.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;// click code here<br />
&nbsp;&nbsp;&nbsp;&nbsp; NVAR mu<br />
&nbsp;&nbsp;&nbsp;&nbsp; Variable mu_shift<br />
&nbsp;&nbsp;&nbsp;&nbsp; Display<br />
&nbsp;&nbsp;&nbsp;&nbsp; for ( mu_shift=-0.15; mu_shift&lt;=0.151; mu_shift+=mu)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub4_extract(mu_shift)<br />
&nbsp;&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp;&nbsp;&nbsp;&nbsp; Legend/C/N=text0/F=0/B=1/A=MC/X=30.00/Y=25.00<br />
&nbsp;&nbsp;&nbsp;&nbsp; ModifyGraph width=0,height=0<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch</p>

<p>&nbsp;return 0<br />
End</p>

<p>//fourth main<br />
Function sub4_extract(mu)<br />
&nbsp; Variable mu<br />
&nbsp; WAVE Ef_eV, T_K, N, DOS_Ef, Seebeck, S_t, R_H, kappa0, c, chi<br />
&nbsp;<br />
&nbsp; Variable Num_of_Wave, i, j, k, num_of_temp<br />
&nbsp; Variable mu_low, mu_high<br />
&nbsp; Num_of_Wave = DimSize(T_K,0)<br />
&nbsp; Make/N=(Num_of_Wave) K_tempo, Seebeck_for_K_tempo<br />
&nbsp;<br />
&nbsp; i = 0; j = 0; k = 0<br />
&nbsp; do<br />
&nbsp;&nbsp;&nbsp; if ( Ef_eV[i] &lt;= mu &amp;&amp; mu &lt;= Ef_eV[i+1] )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mu_low = Ef_eV[i]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mu_high = Ef_eV[i+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = k + 1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( T_K[i-k] &lt; T_K[i-k+1] )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_of_temp = k<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(k=0;k &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; K_tempo[k] = T_K[i+k+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seebeck_for_K_tempo[k] = (Seebeck[i+k+1] - Seebeck[i-num_of_temp+k+1]) * (mu - mu_low) / ( mu_high - mu_low ) +&nbsp; Seebeck[i-num_of_temp+k+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //print&nbsp; T_K[i+k+1], T_K[i-num_of_temp+k+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //print&nbsp; Seebeck[i+k+1], Seebeck[i-num_of_temp+k+1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<br />
&nbsp;&nbsp;&nbsp; endif<br />
&nbsp;&nbsp;&nbsp; i = i +1<br />
&nbsp; while ( i &lt; (DimSize(T_K,0) -1) )<br />
&nbsp;<br />
&nbsp; String name_of_wave<br />
&nbsp; name_of_wave = &quot;Seebeck_at_&quot; + num2str(mu) + &quot;_eV&quot;<br />
&nbsp; Make/O/N=(num_of_temp) temp_K, $name_of_wave<br />
&nbsp; Wave Seebeck_for_K = $name_of_wave</p>

<p>&nbsp; temp_K = K_tempo<br />
&nbsp; Seebeck_for_K = Seebeck_for_K_tempo * 10^6<br />
&nbsp;<br />
&nbsp; AppendToGraph&nbsp; Seebeck_for_K vs temp_K<br />
&nbsp;<br />
&nbsp; //setting graph<br />
&nbsp; ModifyGraph mode=4,marker=19,msize=4<br />
&nbsp; ModifyGraph tick=2,mirror=1,fSize=14,standoff=0,font=&quot;Arial&quot;<br />
&nbsp; Label left &quot;<a>\\Z14\rSeebeck</a> coefficients / <a>\\F'Symbol'm\\F'Arial'V</a>必<a>\\S-1</a>&quot;<br />
&nbsp; ModifyGraph tick(bottom)=2,mirror(bottom)=1,fSize(bottom)=14,standoff(bottom)=0<br />
&nbsp; ModifyGraph font(bottom)=&quot;Arial&quot;<br />
&nbsp; Label bottom &quot;<a>\\Z14\\F'Arial'Temperature</a> / K&quot;<br />
&nbsp; SetAxis bottom 0,2000<br />
&nbsp; ModifyGraph margin(left)=57<br />
&nbsp; ModifyGraph margin(bottom)=43<br />
&nbsp; ModifyGraph width=340.157,height=226.772<br />
&nbsp; Legend/C/N=text0/F=0/B=1/A=MC/X=30.00/Y=40.00<br />
&nbsp;<br />
&nbsp; KillWaves K_tempo, Seebeck_for_K_tempo<br />
&nbsp;<br />
End</p>

<p>---------------------------------------------------<br />
case.traceを一般テキストをロードで読み込む。上記は、マクロから seebeck_panel を選択する。上から順番に押していけばよい。最初の一番目は一度だけでよい。<br />
<br />
回折パターンを回転対称分だけ平均するマクロ<br />
---------------------------------------------------<br />
#pragma rtGlobals=1&nbsp;&nbsp;// Use modern global access method.<br />
// ver.1.00<br />
<br />
Macro electron_diffraction()<br />
<br />
NewPanel/W=(0, 0, 220, 70)<br />
<br />
DrawText 5,20,&quot;This program can read *.tif or *.png file&quot;<br />
SetDrawEnv fname= &quot;Arial&quot;<br />
<br />
DrawText 20,45,&quot;fold:&quot;<br />
SetDrawEnv fname= &quot;Arial&quot;<br />
<br />
PopupMenu popup0 proc=PopMenuProc<br />
PopupMenu popup0 pos={50,28}<br />
PopupMenu popup0 value=&quot;2;3;4;5;6;8;10;12&quot;<br />
PopupMenu popup0 font=&quot;Arial&quot;<br />
<br />
Button button0 title=&quot;area&quot;,proc=ButtonProc<br />
Button button0 pos={94,28}<br />
Button button0 size={50,20}<br />
<br />
Button button1 title=&quot;plot&quot;, proc=ButtonProc_1<br />
Button button1 pos={154,28}<br />
Button button1 size={50,20}<br />
<br />
DrawText 8,66,&quot;wave (image) name is \&quot; image \&quot; only&quot;<br />
<br />
String/G origin_image=ImageNameList(&quot;Graph0&quot;,&quot;;&quot;)<br />
Variable/G fold=2<br />
<br />
End<br />
<br />
Function PopMenuProc(pa) : PopupMenuControl<br />
&nbsp;STRUCT WMPopupAction &amp;pa<br />
<br />
&nbsp;switch( pa.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;Variable popNum = pa.popNum<br />
&nbsp;&nbsp;&nbsp;String popStr = pa.popStr<br />
&nbsp;&nbsp;&nbsp;NVAR fold<br />
&nbsp;&nbsp;&nbsp;fold = str2num(pa.popStr)<br />
&nbsp;&nbsp;&nbsp;ShowInfo<br />
&nbsp;&nbsp;&nbsp;Wave image<br />
&nbsp;&nbsp;&nbsp;Variable/G NLP, NLQ<br />
&nbsp;&nbsp;&nbsp;NLP = DimSize(image,0)<br />
&nbsp;&nbsp;&nbsp;NLQ = DimSize(image,1)<br />
&nbsp;&nbsp;&nbsp;Cursor/I/P A, image, NLP/2, NLQ/2<br />
&nbsp;&nbsp;&nbsp;Cursor/I/P B, image, 0, NLQ/2<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch<br />
<br />
&nbsp;return 0<br />
End<br />
<br />
Function ButtonProc(ba) : ButtonControl<br />
&nbsp;STRUCT WMButtonAction &amp;ba<br />
<br />
&nbsp;switch( ba.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;// click code here<br />
&nbsp;&nbsp;&nbsp;Variable/G A_p,A_q,B_p,B_q<br />
&nbsp;&nbsp;&nbsp;A_p=pcsr(A)<br />
&nbsp;&nbsp;&nbsp;A_q=qcsr(A)<br />
&nbsp;&nbsp;&nbsp;B_p=pcsr(B)<br />
&nbsp;&nbsp;&nbsp;B_q=qcsr(B)<br />
&nbsp;&nbsp;&nbsp;//DoWindow/R/K 'Graph1'<br />
&nbsp;&nbsp;&nbsp;//DoWindow/R/S='Graph1' Graph0<br />
&nbsp;&nbsp;&nbsp;//NewImage $image<br />
&nbsp;&nbsp;&nbsp;//SVAR origin_image<br />
&nbsp;&nbsp;&nbsp;//origin_image=ImageNameList(&quot;Graph0&quot;,&quot;;&quot;)<br />
&nbsp;&nbsp;&nbsp;ShowInfo<br />
&nbsp;&nbsp;&nbsp;//Cursor/I/P A, $origin_image, A_p, A_q<br />
&nbsp;&nbsp;&nbsp;//Cursor/I/P B, $origin_image, B_p, B_q<br />
&nbsp;&nbsp;&nbsp;Cursor/I/P A, image, A_p, A_q<br />
&nbsp;&nbsp;&nbsp;Cursor/I/P B, image, B_p, B_q<br />
&nbsp;&nbsp;&nbsp;Make/O/N=360 xPoints, yPoints<br />
&nbsp;&nbsp;&nbsp;Variable i, r<br />
&nbsp;&nbsp;&nbsp;r = sqrt((xcsr(B)-xcsr(A))^2+(vcsr(B)-vcsr(A))^2)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0; i&lt;360; i+=1)<br />
&nbsp;&nbsp;&nbsp;&nbsp; xPoints[i]=r*cos(Pi/180*i)+xcsr(A)<br />
&nbsp;&nbsp;&nbsp;&nbsp; yPoints[i]=r*sin(Pi/180*i)+vcsr(A)<br />
&nbsp;&nbsp;&nbsp;endfor<br />
&nbsp;&nbsp;&nbsp;AppendToGraph/T yPoints vs xPoints<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch<br />
<br />
&nbsp;return 0<br />
End<br />
<br />
Function ButtonProc_1(ba) : ButtonControl<br />
&nbsp;STRUCT WMButtonAction &amp;ba<br />
<br />
&nbsp;switch( ba.eventCode )<br />
&nbsp;&nbsp;case 2: // mouse up<br />
&nbsp;&nbsp;&nbsp;// click code here<br />
&nbsp;&nbsp;&nbsp;NVAR fold<br />
&nbsp;&nbsp;&nbsp;SVAR origin_image<br />
&nbsp;&nbsp;&nbsp;rotation_plot(fold, origin_image)<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;&nbsp;case -1: // control being killed<br />
&nbsp;&nbsp;&nbsp;break<br />
&nbsp;endswitch<br />
<br />
&nbsp;return 0<br />
End<br />
<br />
// main routine<br />
Function rotation_plot(fold, origin_image)<br />
&nbsp; Variable fold<br />
&nbsp; String origin_image<br />
&nbsp; NVAR NLP, NLQ<br />
&nbsp; Make/O/N=(NLP,NLQ)&nbsp; rotate_origin_image<br />
&nbsp; Wave rotate_origin_image = $origin_image<br />
&nbsp; Variable i, j<br />
&nbsp; Variable p, q, rp, rq<br />
&nbsp; NVAR&nbsp; A_p,A_q,B_p,B_q<br />
&nbsp; Variable Max_p, Max_q<br />
&nbsp; Wave image<br />
&nbsp; //<br />
&nbsp; Max_p = sqrt((pcsr(B)-pcsr(A))^2+(qcsr(B)-qcsr(A))^2)<br />
&nbsp; Max_q = Max_p<br />
&nbsp; Make/O/N=(NLP,NLQ) rotate_image, sum_image<br />
&nbsp; //<br />
&nbsp; for(q=-Max_q;q&lt;=Max_q;q+=1)<br />
&nbsp;&nbsp;&nbsp; for(p=-Max_p;p&lt;=Max_p;p+=1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum_image[p+A_p][q+A_q] = 0<br />
&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp; endfor<br />
&nbsp; //<br />
&nbsp; for(i=0;i &nbsp;&nbsp;&nbsp; for(q=-Max_q;q&lt;=Max_q;q+=1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(p=-Max_p;p&lt;=Max_p;p+=1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rp = p*cos(Pi/180*360/fold*i) - q*sin(Pi/180*360/fold*i)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rq = p*sin(Pi/180*360/fold*i) + q*cos(Pi/180*360/fold*i)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rotate_image[p+A_p][q+A_q]=image[rp+A_p][rq+A_q]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp;&nbsp;&nbsp; //<br />
&nbsp;&nbsp;&nbsp; for(q=-Max_q;q&lt;=Max_q;q+=1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(p=-Max_p;p&lt;=Max_p;p+=1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum_image[p+A_p][q+A_q] = sum_image[p+A_p][q+A_q] + rotate_image[p+A_p][q+A_q] / fold<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp;&nbsp;&nbsp; endfor<br />
&nbsp; endfor<br />
&nbsp; NewImage sum_image<br />
End<br />
---------------------------------------------------<br />
&nbsp; 画像は .tif または .png で込みこむことが可能。Igorにファイルをドラッグ&amp;ドロップしたら、「イメージをロード」で「イメージをj表示」にチェックを入れて、「新規 ウェーブ名：」を選択して実行を押す。新規ウェーブ名は'image'がディフォルトになっている。マクロ（M)からマクロを起動させて、左から右へと薦 めていく。まず、回転対称性の指定する。次に、カーソルAを中心に、Bを外側において計算範囲を指定する。areaを押せば確実に計算できる範囲が分か る。それで問題なければ、plot を押す。<br />
&nbsp; このプログラムは綺麗に画像が撮れていないと平均するのでピークがぼけたりする。綺麗に画像を取れるようにカメラを調整して、良い画像を取らなければならない。作ってはみたものの余り使い道がなさそうに思えてガッカリした。<br />
<br />
--------------------------------------------------------------------------------<br />
■ Igor macro（上級編）<br />
<br />
フィッティング<br />
---------------------------------------------------<br />
#pragma rtGlobals=1&nbsp;&nbsp;&nbsp; // Use modern global access method<br />
Menu &quot;Fit&quot;<br />
&nbsp; &quot;Open Input Parameters Panel&quot;, Input_Parameters_Panel()<br />
&nbsp; submenu &quot;Curve fitting&quot;<br />
&nbsp;&nbsp;&nbsp; &quot;Subtract background&quot;, Sub_BG()&nbsp;&nbsp;&nbsp; //&nbsp;Subtract Back&nbsp;Ground<br />
&nbsp;&nbsp;&nbsp; &quot;-&quot;&nbsp;&nbsp;&nbsp; //&nbsp;Edit a line<br />
&nbsp;&nbsp;&nbsp; &quot;Coefficients Table&quot;, Coef_Table()&nbsp;&nbsp;&nbsp; //&nbsp; Coefficients&nbsp;data for&nbsp;fitting<br />
&nbsp;&nbsp;&nbsp; &quot;Fittng Parameters In&quot;, Fit_Para_in()&nbsp;&nbsp;&nbsp; // Fitting parameters input<br />
&nbsp;&nbsp;&nbsp; &quot;-&quot;&nbsp;&nbsp; &nbsp;// Edit a line<br />
&nbsp;&nbsp;&nbsp; &quot;Fitting&quot;, Fitting()&nbsp;&nbsp;&nbsp; // Run fitting process<br />
&nbsp; End<br />
End<br />
// -----------------------<br />
Proc Input_Parameters_Panel()<br />
&nbsp; General_Parameters()<br />
&nbsp; Fitting_Condition_Select_Panel()<br />
End Macro<br />
<br />
Function General_Parameters()<br />
&nbsp; // 他の部分で用いるパラメーターはここでグローバル変数の宣言(/G)をしておくと、<br />
&nbsp; //&nbsp;他で利用可能な見やすい引数とできる。<br />
&nbsp; //&nbsp;下記はフィッティングするためのグローバル変数を宣言。<br />
&nbsp; Variable /G&nbsp;Start_Wave_Number,&nbsp;Last_Wave_Number<br />
&nbsp; String /G Wave_Name<br />
&nbsp; // フィッティング方法の違いを選択できるように下記のような変数も作成しておくとよい。<br />
&nbsp; Variable /G Function_type<br />
End Function<br />
<br />
Window Fitting_Condition_Select_Panel()<br />
//&nbsp; Silent 1; PauseUpdate&nbsp;&nbsp;&nbsp; // No show command line for&nbsp;faster process<br />
//&nbsp;X1 -Y9 は数値に換えて下さい。<br />
&nbsp; NewPanel /W=(X1, Y1, X2, Y2)&nbsp;&nbsp;&nbsp; //&nbsp;open&nbsp;panel<br />
&nbsp; ModifyPanel cbRGB=(R, G, B)&nbsp;&nbsp;&nbsp; // change color<br />
&nbsp; SetDrawLayer UserBack&nbsp;&nbsp;&nbsp; //<br />
&nbsp; SetDrawEnv fname=&quot;Arial&quot;, fsize=11, fstyle=1&nbsp;&nbsp;&nbsp; // Set character<br />
&nbsp; DrawText X3, Y4, &quot;Fitting Condition Select&quot;&nbsp;&nbsp;&nbsp; // show some character<br />
&nbsp; DrawLine X4, Y4, X5, Y5&nbsp; // draw line<br />
&nbsp; //&nbsp;ボタンが表示される。必要なデータのパスを入力する欄が出るようになる。<br />
&nbsp; Button&nbsp;Button_name, pos={X6,Y6}, size={X7,Y7}, proc=Button_Proc\Data_path, title=&quot;Set data path&quot;<br />
&nbsp; //&nbsp;Fit A、Fit B、 Fit C が選択可能な欄が出る。<br />
&nbsp; // PopupMenuの後の名称は、下のPopupMenuに関連付けるために利用される。<br />
&nbsp;&nbsp;PopupMenu&nbsp;Popup_name, pos={X6,Y6}, size={X7,Y7}, proc=Button_Proc\Data_path, title=&quot;Function type&quot;<br />
&nbsp;&nbsp;PopupMenu&nbsp;Popup_name,&nbsp;mode=2,value= #&quot;\&quot; Fit A; Fit B; Fit C\&quot;&quot;<br />
&nbsp; //&nbsp;フィッティングするWave名を入力&nbsp;<br />
&nbsp; SetVariable Set_Wave_Name, pos={X12, Y12}, size={X13, Y13}, title=&quot;Wave_Name&quot;<br />
&nbsp; SetVariable Set_Wave_Name, font=&quot;Arial&quot;, fSize=12, value= Wave_Name<br />
&nbsp; //&nbsp;フィッティングするWaveでの開始点<br />
&nbsp; SetVariable&nbsp;Set_Start_Fitting_Point, pos={X8, Y8}, size={X9, Y9}, title=&quot;Start Fitting Point&quot;<br />
&nbsp; SetVariable Set_Start_Fitting_Point, font=&quot;Arial&quot;,fSize=12,value= Start_Wave_Number<br />
&nbsp; //&nbsp;フィッティングするWaveでの終了点<br />
&nbsp; SetVariable Set_Last_Fitting_Point, pos={X10, Y10}, size={X11, Y11}, title=&quot;Last Fitting Point&quot;<br />
&nbsp; SetVariable Set_Last_Fitting_Point, font=&quot;Arial&quot;,fSize=12,value= Last_Wave_Number<br />
End Macro<br />
// -----------------------<br />
Proc Input_Sub_BG()<br />
// (省略。上記を参考に作成してみて下さい)<br />
End Macro<br />
// -----------------------<br />
Proc Coef_Table()<br />
&nbsp; if(Function_type ==&nbsp; 1)<br />
&nbsp;&nbsp;&nbsp; Make_Coef_Table_version1()<br />
&nbsp; endif<br />
&nbsp; if(Function_type == 5)<br />
&nbsp;&nbsp;&nbsp; Make_Coef_Table_version5()<br />
&nbsp; endif<br />
End Macro<br />
// -----------------------<br />
Proc Make_Coef_Table_version1()<br />
&nbsp; DoWindow/K Coefficients_Table&nbsp; //&nbsp;Kで所定の名称のウインドウを破棄する<br />
&nbsp; Make/N=14/T/O Coefficients_Name<br />
&nbsp; Make/N=14/D/O Coefficients<br />
&nbsp; Make/N=14/B/O&nbsp; Hold_Flag<br />
&nbsp;&nbsp;ModifyTable size=9 // Pointの表示が見えるようにフォントの大きさを小さく指定する<br />
&nbsp; AppendToTable Coefficients_Table&nbsp; // 列を名前付きウィンドウに追加する<br />
&nbsp; AppendToTable Coefficients<br />
&nbsp; AppendToTable Hold_Flag<br />
&nbsp; // 下記のように ; を用いると組み込み関数を並べて用いることができる。<br />
&nbsp; // alignment=で0は左揃え、1は中央揃え、2は右揃え。widthは幅（ポイント）の指定<br />
&nbsp; ModifyTable&nbsp;alignment=1; ModifyTable width(Coefficients_Name)=90<br />
&nbsp; // 下記のようにするとA1からA14の名称で予め表に入力された状態となる。<br />
&nbsp; Coefficients_Name={&quot;A1&quot;, &quot;A2&quot;,&nbsp;&quot;A3&quot;,&nbsp;&quot;A4&quot;, &quot;A5&quot;,&nbsp;&quot;A6&quot;, &quot;A7&quot;,&nbsp;&quot;A8&quot;,&nbsp;&quot;A9&quot;,&nbsp;&quot;A10&quot;}<br />
&nbsp; Coefficients_Name[10]={&quot;A11&quot;,&nbsp;&quot;A12&quot;, &quot;A13&quot;, &quot;A14&quot;}&nbsp; // 見やすいように区切っている。<br />
&nbsp; DoWindow/C Coefficients_Table&nbsp; // Cで指定された名称にウインドウを変更<br />
&nbsp;<br />
&nbsp; //この後に、上記の様に、フィッティング後の成分を示す表を作ってみるとよい。<br />
End Macro<br />
// -----------------------<br />
Proc Make_Coef_Table_version5()<br />
&nbsp; // 上記を参考にオリジナルのものを作成してみて下さい。<br />
End Macro<br />
// -----------------------<br />
Proc Fit_Para_in()<br />
&nbsp; String wave_name<br />
&nbsp; DoWindow/K Fitting_Graph<br />
&nbsp; Display<br />
&nbsp; DoWindow/C Fitting_Graph<br />
&nbsp; wave_name = Wave_Name<br />
&nbsp; Duplicate/O $wave_name B1, B2, B3, B4, B5, B6<br />
&nbsp; if(Function_type==1)<br />
&nbsp;&nbsp;&nbsp; Fitting_Initial_1()<br />
&nbsp;&nbsp;&nbsp; AppendToGraphe $wave_name,&nbsp;B1, B2, B3, B4, B5, B6<br />
&nbsp; endif<br />
&nbsp;&nbsp;if(Function_type==5)<br />
&nbsp;&nbsp;&nbsp; //&nbsp;上記を参考にオリジナルのものを作成してみて下さい。<br />
&nbsp;&nbsp;endif<br />
End Macro<br />
// -----------------------<br />
Proc Fitting_Initial_1()<br />
&nbsp; Variable i=0, calculation_limit<br />
&nbsp;&nbsp;String String_Hold_Flag=&quot;&quot;<br />
&nbsp; if(function_type==1)<br />
&nbsp;&nbsp;&nbsp; //<br />
&nbsp;&nbsp;&nbsp; wavestats/Q&nbsp;Coefficients; calculation_limit = V_npnts<br />
&nbsp;&nbsp;&nbsp; Do<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String_Hold_Flag = String_Hold_Flag + num2str(Hold_Flag[i])<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 1<br />
&nbsp;&nbsp;&nbsp; While (i &nbsp;&nbsp;&nbsp; Fitting(String_Hold_Flag)<br />
&nbsp; endif<br />
End Macro<br />
// -----------------------<br />
Proc Fitting(String_Hold_Flag)<br />
&nbsp; String String_Hold_Flag<br />
&nbsp;&nbsp;if(function_type==1)<br />
&nbsp;&nbsp; &nbsp;FuncFit/H=String_Hold_Flag /L=<br />
&nbsp; endif<br />
&nbsp; (編集中）<br />
End Macro<br />
---------------------------------------------------<br />
(編集中）<br />
[1] <a href="http://www.ppl.k.u-tokyo.ac.jp/saito/etc.html">http://www.ppl.k.u-tokyo.ac.jp/saito/etc.html</a><br />
[2] <a href="http://nps.sakura.ne.jp/sf/Igor/Igor1.htm">http://nps.sakura.ne.jp/sf/Igor/Igor1.htm</a><br />
[3] <a href="http://www.nips.ac.jp/huinfo/documents/IGOR/igor02.html">http://www.nips.ac.jp/huinfo/documents/IGOR/igor02.html</a><br />
---------------------------------------------------<br />
※ 実験装置からデータを取得する場合、PCのアースをしっかりと接続しないと、ノイズが大きくなります。3端子がしっかりと接続されていることを確認しましょう。<br />
---------------------------------------------------<br />
<br />
--------------------------------------------------------------------------------<br />
■ I・シバース、M・クラーク 著、『入門FORTRAN77』 啓学出版<br />
終りに（の部分を抜粋）<br />
これまに述べたアプローチには幾つかの欠点があります。最も主要なものは、デザインのときにどうのような決定がなされたかを示す情報がプログラムにほとん ど含まれないということです。つまり、プログラムを作る過程の情報やプログラムのテストやデバッグ時の情報がまったく含まれていないわけです。この欠点は もしプログラムを少しでも変更しようとすると大きな問題となります。そこで、デザインの過程の情報をプログラムにコメントの形で挿入する習慣をつけること をお勧めします。さらに、考えられる重要なエラーについてもコメントにしておくとよいでしょう。また、採用するのをやめたことについてもコメントにしてお くべきです。そのようにすれば、次のときにより良いアプローチをとることができるでしょう。プログラムを作っているときの考えを文章にしたり、他人に説明 しようとするのは、自分の論理の誤りを見つけ出すためにとても役に立ちます。それは特に初心者にいえることです。初心者のときに小さなグループで仕事をす るのは、長いであろうプログラミング経験の中で、きっと大きな意味を持つでしょう。最後に、無視されるかもしれませんが、ひとつお願いをしておきましょ う。多くの人たちがプログラミングを、作る人の個性の延長上に捉えています。プログラムはその人自身の創造物なので、その批評は個人への批評とみなされま す。これを乗り越えてください。もし、あなたのエゴがあなたのプログラムから切り離されるなら、助言を得やすくなるばかりでなく、弊害を避けることがで き、友人との友好関係も続けることができるでしょう。そして、プログラムも進歩するでしょう。しかし、本当はプログラムへの批評は個人への批評ではないの です。<br />
--------------------------------------------------------------------------------<br />
プログラミングの素朴な疑問25<br />
Nikkie software 2011年3月 P.12<br />
--------------------------------------------------------------------------------<br />
プログラミング 途中でぐじけないために必ず知っておきたいこと<br />
Nikkei software 2009年7月 P.16<br />
--------------------------------------------------------------------------------<br />
Windows 基本テクニック　プログラミング50<br />
Nikkei software 2010年2月 P.17<br />
--------------------------------------------------------------------------------<br />
小野和俊のプログラマ独立独歩<br />
Nikkei software 2010年2月 P.6<br />
Nikkei software 2010年6月 P.6<br />
Nikkei software 2010年9月 P.8<br />
Nikkei software 2010年11月 P.8<br />
--------------------------------------------------------------------------------<br />
基礎を固めて応用自在！　最新Visual Basic講座<br />
Nikkei software 2010年12月 P.106<br />
--------------------------------------------------------------------------------<br />
VBA, C#, Java, Rubyで自在に操る！<br />
プログラマ的Excel使いこなし術<br />
Nikkei software 2010年12月 P.44<br />
--------------------------------------------------------------------------------<br />
3日で学ぶC言語<br />
Nikkei software 2010年11月 P.21<br />
本当にゼロから始めるC/C++<br />
Nikkei software 2009年5月 P.116<br />
Nikkei software 2009年6月 P.92<br />
Nikkei software 2009年7月 P.84<br />
Nikkei software 2009年8月 P.82<br />
Nikkei software 2009年9月 P.94<br />
Nikkei software 2009年10月 P.106<br />
Nikkei software 2009年11月 P.106<br />
Nikkei software 2009年12月 P.106<br />
Nikkei software 2010年1月 P.116<br />
Nikkei software 2010年2月 P.123<br />
Nikkei software 2010年3月 P.116<br />
Nikkei software 2010年4月 P.108<br />
Nikkei software 2010年5月 P.110<br />
Cエキスパートへの道<br />
Nikkei software 2010年5月 P.90<br />
Nikkei software 2010年6月 P.106<br />
Nikkei software 2010年7月 P.130<br />
Nikkei software 2010年8月 P.122<br />
Nikkei software 2010年9月 P.132<br />
Nikkei software 2010年10月 P.140<br />
Nikkei software 2010年11月 P.140<br />
Nikkei software 2010年12月 P.138<br />
Nikkei software 2011年1月 P.148<br />
Nikkei software 2011年2月 P.132<br />
--------------------------------------------------------------------------------<br />
言語仕様、ライブラリ、GUIでC#を最短攻略!<br />
Nikkei software 2011年2月 P.15<br />
コンソール（C言語）GUI（C#)WEB（PHP）プログラミングの始め方<br />
Nikkei software 2010年4月 P.12<br />
--------------------------------------------------------------------------------<br />
マルチコアを使いこなせ！　並列プログラミング入門<br />
Visual Basic と C++ で様々な手法にチャレンジ<br />
Nikkei software 2010年9月 P.50<br />
--------------------------------------------------------------------------------<br />
最速で学ぶObjective-C<br />
Nikkei software 2010年3月 P.72<br />
Nikkei software 2010年4月 P.64<br />
--------------------------------------------------------------------------------<br />
Javaで始めるプログラミング<br />
Nikkei software 2010年5月 P.68<br />
Nikkei software 2010年6月 P.66<br />
Nikkei software 2010年7月 P.94<br />
Nikkei software 2010年8月 P.88<br />
Nikkei software 2010年9月 P.98<br />
Nikkei software 2010年10月 P.112<br />
Nikkei software 2010年11月 P.114<br />
Nikkei software 2010年12月 P.114<br />
Nikkei software 2011年1月 P.122<br />
Nikkei software 2011年2月 P.112<br />
Nikkei software 2011年3月 P.118<br />
Nikkei software 2011年4月 P.114<br />
じっくり学ぶJavaツール<br />
Nikkei software 2010年1月 P.88<br />
Nikkei software 2010年2月 P.94<br />
Nikkei software 2010年3月 P.88<br />
Nikkei software 2010年4月 P.82<br />
Nikkei software 2010年5月 P.118<br />
Nikkei software 2010年6月 P.114<br />
Nikkei software 2010年7月 P.136<br />
Nikkei software 2010年8月 P.128<br />
Nikkei software 2010年9月 P.138<br />
Nikkei software 2010年10月 P.146<br />
Nikkei software 2010年11月 P.146<br />
Nikkei software 2010年12月 P.144<br />
いまどきのJava Script<br />
Nikkei software 2010年12月 P.120<br />
要件定義からテキストまでJavaでアプリケーションを作り上げよう！<br />
Nikkei software 2010年5月 P.12<br />
--------------------------------------------------------------------------------<br />
フリー・プログラマの華麗な生活<br />
他人のソースコードを楽に読む方法 Nikkei software 2010年9月 P.97<br />
--------------------------------------------------------------------------------<br />
プログラマ娯楽室<br />
Nikkei software 2010年7月 P.114<br />
Nikkei software 2010年8月 P.106<br />
Nikkei software 2010年9月 P.116<br />
Nikkei software 2010年10月 P.124<br />
Nikkei software 2010年11月 P.130<br />
Nikkei software 2010年12月 P.126<br />
Nikkei software 2011年1月 P.136<br />
Nikkei software 2011年2月 P.120<br />
Nikkei software 2011年3月 P.126<br />
--------------------------------------------------------------------------------<br />
Rubyで楽々システム開発<br />
Nikkei software 2010年5月 P.98<br />
Nikkei software 2010年6月 P.90<br />
Nikkei software 2010年7月 P.118<br />
Nikkei software 2010年8月 P.110<br />
Nikkei software 2010年9月 P.120<br />
Nikkei software 2010年10月 P.128<br />
Nikkei software 2010年11月 P.134<br />
Nikkei software 2010年12月 P.130<br />
Nikkei software 2011年1月 P.140<br />
Nikkei software 2011年2月 P.124<br />
Nikkei software 2011年3月 P.130<br />
最前線のプロが直伝！ 2D&amp;3Dゲームプログラミング Nikkei software 2011年1月<br />
--------------------------------------------------------------------------------<br />
Androiddプログラミングのレシピ<br />
Nikkei software 2010年12月 P.94<br />
Nikkei software 2011年1月 P.96<br />
Nikkei software 2011年2月 P.84<br />
Nikkei software 2011年3月 P.94<br />
Nikkei software 2011年4月 P.102<br />
自分で作るからAndroidアプリは面白い! Nikkei Linux 2011年2月 P.42<br />
本格派ゲームプログラミング入門&nbsp;Nikkei software 2010年6月 P. 31<br />
--------------------------------------------------------------------------------<br />
理解して学ぶWebデザイン<br />
Nikkei software 2011年3月 P.82<br />
Nikkei software 2011年4月 P.90<br />
--------------------------------------------------------------------------------<br />
初歩からの組み込みプログラミング<br />
Nikkei software 2010年7月 P.98<br />
Nikkei software 2010年8月 P.74<br />
Nikkei software 2010年9月 P.74<br />
Nikkei software 2010年10月<br />
Nikkei software 2010年11月 P.84<br />
Nikkei software 2010年12月 P.70<br />
Nikkei software 2011年1月 P.78<br />
--------------------------------------------------------------------------------<br />
挫折させないたった900行でオリジナル言語<br />
スクリプト言語<br />
Nikkei&nbsp; software 2010年8月 P.14<br />
--------------------------------------------------------------------------------<br />
Google Go プログラミング入門<br />
Nikkei software 2010年8月 P.44<br />
--------------------------------------------------------------------------------<br />
動いて楽しいアルゴリズム！<br />
Nikkei software 2009年8月 P.96<br />
Nikkei software 2009年9月 P.108<br />
Nikkei software 2009年10月 P.122<br />
Nikkei software 2009年11月 P.114<br />
Nikkei software 2009年12月 P.116<br />
Nikkei software 2010年1月 P.104<br />
Nikkei software 2010年2月 P.110<br />
Nikkei software 2010年3月 P.104<br />
Nikkei software 2010年4月 P.96<br />
Nikkei software 2010年5月 P.86<br />
Nikkei software 2010年6月 P.102<br />
--------------------------------------------------------------------------------<br />
日経ソフトウェア　2002年4月号<br />
だれでも作れるインストール・プログラム<br />
--------------------------------------------------------------------------------</p>
