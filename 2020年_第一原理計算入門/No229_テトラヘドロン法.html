　ここではテトラヘドロン法について解説する。非常に重要なアルゴリズムとプログラムであるが、一般的に利用できるプログラムは容易に見つからない。筆者ももう若くないし、職も続かないので、若い人に頼みたい。<br />
--------------------------------------------------------------------------------<br />
■ 理論的背景の理解の仕方<br />
&nbsp; テトラヘドロン法の簡単な概略を知りたい場合は文献[1]を読むことをオススメしたい。計算式は文献[2]も参照しながら読み込んでいくとよい。<br />
Reference<br />
[1] H. Sato et al., Phil. Mag. 93 (2013) 3029.<br />
[2] G.Lehmann and M.Taut, phys. stat. sol. (b) 54 (1972) 469.<br />
--------------------------------------------------------------------------------<br />
■ 引数<br />
NPX,NPY, NPZ： それぞれh,k,l方向でのテトラへドロン法での分割数。<br />
NP: 分割したメッシュに付けられた番号。<br />
EOA:　Electrons over atoms<br />
I2: NPX, NPY, NPZで分割したメッシュの番号NPに対応するklistにある規約表現上の番号(IEX).<br />
AMA: NPT（NPX, NPY, NPZで分割した総メッシュ数）に対応させたklistでの番号に対するエネルギー(eV) (AMA2)。<br />
AKK: NPT（NPX, NPY, NPZで分割した総メッシュ数）に対応させたklistでの番号に対するC^2 (BFFF)。<br />
AKKB: NPT（NPX, NPY, NPZで分割した総メッシュ数）に対応させたklistでの番号に対するK^2 (BKKK)。<br />
S: エネルギー<br />
F: C^2<br />
FB: K^2<br />
FC: (K^2)^2<br />
CALL SORT: 4つあるSを昇順に並べた基準でデータが揃えられる。<br />
NE1: エネルギー差分(S(1)-EM(1))/DE。もし、EBよりもS(1)が小さければNE1=-1<br />
V: 四面体の体積<br />
DELTA:<br />
D1:<br />
D2:<br />
D4:<br />
AM: テキスト中のMに該当する。<br />
V1: V/DELTA<br />
DEE: E-S(1 or 2 or 3 or 4)<br />
CN: よくテキスト見かける式（&Delta;S/|&nabla;E|）を計算する。<br />
DF:<br />
DF1:<br />
DF2:<br />
CN:<br />
CN1:<br />
CN2:<br />
FN:C^2に（&Delta;S/|&nabla;E|）を掛ける。<br />
FNB:K^2に（&Delta;S/|&nabla;E|）を掛ける。Kcgを計算。<br />
FND:(K^2)^2に（&Delta;S/|&nabla;E|）を掛ける。<br />
SNT:SNの総和。CNT(つまり、DOS) をバンドの底からEまで積分した状態数。<br />
CNT,CC:CNの総和。よくテキスト見かける式&Sigma;（&Delta;S/|&nabla;E|）を計算する。DOSが得られる。CCが0以下のときは割られる方は0にする。<br />
FNT,C2:FNの総和<br />
FNTB,C2B:FNBの総和<br />
FNTC,C2C:FNCの総和<br />
FNTD,C2D:FNDの総和<br />
TNE: トータルの電子数<br />
EE: エネルギー<br />
CPP,CFC,CCC: K^2<br />
CPP1,CFC1,CCC1: EOA<br />
CP,CF: C^2<br />
<br />
■ サブルーチンの解説（下記のプログラムは計算に時間が掛かるが、単純であり、どのような構造に対してもプログラムを変えずに計算が可能であるという利点がある）<br />
CALL TGEN： outputkgenの形式にあわせてNPZ, NPY, NPXを変えていき、それに順番に番号をつける。そして、N1(NP)-N7(NP)までの七つの分類に分けて整理する。つまり、全体を六面体で分割し、さらに六面体を6つの四面体に分割したデータを作る。<br />
<br />
CALL FDENS: TGENで分割した四面体の番号NPに対してPDNSで値を計算する。<br />
<br />
CALL PDNS: 四面体（テトラへドロン）での計算をするルーチン。&nbsp;SORTを呼び出して昇順に並べた後に処理が行われる。「■ 理論的背景の理解の仕方」で分かるように、幾つかの場合に分けて計算をしている。基本的に、[1] H. Sato et al., Phil. Mag. 93 (2013) 3029.と [2] G.Lehmann and M.Taut, phys. stat. sol. (b) 54 (1972) 469.の方法に従っているので式とプログラムの対応付けや理解がしやすいと思う。<br />
<br />
CALL SORT: ソートのルーチン。昇順に並べる。<br />
--------------------------------------------------------------------------------<br />
■ プログラム<br />
<br />
□ TGEN： outputkgenの形式にあわせてNPZ, NPY, NPXを変えていき、それに順番に番号をつける。そして、N1(NP)-N7(NP)までの七つの分類に分けて整理する。つまり、全体を六面体で分割し、さらに六面体を6つの四面体に分割したデータを作る。<br />
!----------------------------------------------------------------------<br />
subroutine TGEN(NPXD,NPYD,NPZD,IC,N1,N2,N3,N4,N5,N6,N7)<br />
&nbsp; use common<br />
&nbsp; implicit none<br />
!---------------------------------------------------------------<br />
!&nbsp;&nbsp; *&nbsp;&nbsp; DEFINE TETRAHEDRA ASSOCIATED WITH EACH K-POINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br />
!&nbsp;&nbsp; *&nbsp;&nbsp; THE K-SPACE MESH IMPLIED SHOULD BE CONSISTENT WITH THAT*<br />
!&nbsp;&nbsp; *&nbsp;&nbsp; GENERATED BY SUBROUTINE &lt;MESH&gt; IN &lt;STR&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br />
!&nbsp;&nbsp; *&nbsp;&nbsp; SIMPLE CUBIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br />
!---------------------------------------------------------------<br />
&nbsp; integer(4),intent(in):: NPXD,NPYD,NPZD<br />
&nbsp; integer(4),intent(inout):: IC(NPXD,NPYD,NPZD)<br />
&nbsp; integer(4),intent(inout):: N1(NPT),N2(NPT),N3(NPT),N4(NPT),N5(NPT),N6(NPT),N7(NPT)<br />
&nbsp; !<br />
&nbsp; integer(4):: X,Y,Z<br />
&nbsp; integer(4):: NPXM,NPYM,NPZM<br />
&nbsp; integer(4):: NP,LP<br />
&nbsp; real(8):: DKX,DKY,DKZ<br />
&nbsp; !<br />
&nbsp; NPX=NPXD<br />
&nbsp; NPY=NPYD<br />
&nbsp; NPZ=NPZD<br />
&nbsp; !<br />
&nbsp; NPXM=NPX-1<br />
&nbsp; NPYM=NPY-1<br />
&nbsp; NPZM=NPZ-1<br />
&nbsp; !<br />
&nbsp; DKX=1.d0/(float(NPXM))<br />
&nbsp; DKY=1.d0/(float(NPYM))<br />
&nbsp; DKZ=1.d0/(float(NPZM))<br />
&nbsp; V=&nbsp; DKX*DKY*DKZ / 3.0<br />
&nbsp; write(6,*) ' start!! PNT=', 'V=',V<br />
!<br />
! be careful! h,k,l start at 0, but fortran array start at 1.<br />
! Please, remember X:1 = h:0, Y:1 = k:0 , Z:1 = l:0<br />
!<br />
&nbsp; NP=0<br />
&nbsp; ! write(6,*) NPX, NPY, NPZ<br />
&nbsp; do X=1,NPX<br />
&nbsp;&nbsp;&nbsp; do Y=1,NPY<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do Z=1,NPZ<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NP=NP+1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IC(X,Y,Z)=NP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end do<br />
&nbsp;&nbsp;&nbsp; end do<br />
&nbsp; end do<br />
&nbsp; !<br />
&nbsp; ! write(6,*) ' total k-point',NP<br />
&nbsp; !<br />
&nbsp; NP=0<br />
&nbsp; DO X=1,NPX-1<br />
&nbsp;&nbsp;&nbsp; DO Y=1,NPY-1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO Z=1,NPZ-1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NP=IC(X,Y,Z)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N1(NP)=IC(X+1,Y&nbsp; ,Z&nbsp; )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N2(NP)=IC(X+1,Y+1,Z&nbsp; )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N3(NP)=IC(X+1,Y+1,Z+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N4(NP)=IC(X+1,Y&nbsp; ,Z+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N5(NP)=IC(X&nbsp; ,Y&nbsp; ,Z+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N6(NP)=IC(X&nbsp; ,Y+1,Z+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N7(NP)=IC(X&nbsp; ,Y+1,Z&nbsp; )<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end do<br />
&nbsp;&nbsp;&nbsp; end do<br />
&nbsp; end do<br />
&nbsp; return<br />
end subroutine TGEN<br />
!----------------------------------------------------------------------<br />
<br />
□ FDENS: TGENで分割した四面体の番号NPに対してPDNSで値を計算する。<br />
!----------------------------------------------------------------------<br />
subroutine FDENS(NPXD,NPYD,NPZD,IC,NPT,N1,N2,N3,N4,N5,N6,N7)<br />
&nbsp; implicit none<br />
&nbsp; integer(4),intent(in):: NPXD, NPYD, NPZD, NPT<br />
&nbsp; integer(4),intent(inout):: IC(NPXD,NPYD,NPZD)<br />
&nbsp; integer(4),intent(inout):: N1(NPT),N2(NPT),N3(NPT),N4(NPT),N5(NPT),N6(NPT),N7(NPT)<br />
&nbsp; integer(4):: I,J,K<br />
&nbsp; integer(4):: NPX,NPY,NPZ<br />
&nbsp; integer(4):: NP,LP<br />
&nbsp; integer(4):: I0,I1,I2,I3,I4,I5,I6,I7<br />
&nbsp; !<br />
&nbsp; NPX=NPXD<br />
&nbsp; NPY=NPYD<br />
&nbsp; NPZ=NPZD<br />
&nbsp; LP=0<br />
&nbsp; DO I=1,NPX-1<br />
&nbsp;&nbsp;&nbsp; DO J=1,NPY-1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DO K=1,NPZ-1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! be careful! Tihs method is calculate tetrahedron including I0+1 range.<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! NPX-1 is OK.<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! NP=NP+1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LP=IC(I,J,K)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I0=LP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I1=N1(LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I2=N2(LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I3=N3(LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I4=N4(LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I5=N5(LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I6=N6(LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I7=N7(LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL PDNS(I0,I1,I2,I3,LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL PDNS(I0,I1,I3,I4,LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL PDNS(I0,I3,I4,I5,LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL PDNS(I0,I3,I5,I6,LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL PDNS(I0,I3,I6,I7,LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL PDNS(I0,I2,I3,I7,LP)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end do<br />
&nbsp;&nbsp;&nbsp; end do<br />
&nbsp; end do<br />
&nbsp; return<br />
end subroutine FDENS<br />
!----------------------------------------------------------------------<br />
<br />
□ PDNS: 四面体（テトラへドロン）での計算をするルーチン。&nbsp;SORTを呼び出して昇順に並べた後に処理が行われる。「■ 理論的背景の理解の仕方」で分かるように、幾つかの場合に分けて計算をしている。基本的に、[1] H. Sato et al., Phil. Mag. 93 (2013) 3029.と [2] G.Lehmann and M.Taut, phys. stat. sol. (b) 54 (1972) 469.の方法に従っているので式とプログラムの対応付けや理解がしやすいと思う。<br />
!----------------------------------------------------------------------<br />
subroutine PDNS(I1,I2,I3,I4,LP)<br />
&nbsp; use constants<br />
&nbsp; use common<br />
&nbsp; use allocate_data<br />
&nbsp; implicit none<br />
!------------------------------------------------------------------<br />
!&nbsp;&nbsp; *&nbsp;&nbsp; CALCULATE STATE DENSITY AND NUMBER OF STATES FOR A SINGLE *<br />
!&nbsp;&nbsp; *&nbsp;&nbsp; TETRAHEDRON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br />
!&nbsp;&nbsp; *&nbsp;&nbsp; CN : STATE DENSITY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br />
!&nbsp;&nbsp; *&nbsp;&nbsp; SN : NUMBER OF STATES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *<br />
!------------------------------------------------------------------<br />
&nbsp; !<br />
&nbsp; integer(4),intent(in):: I1,I2,I3,I4,LP<br />
&nbsp; !<br />
&nbsp; real(8):: S(4),F(4),FB(4),FC(4),G(4)<br />
&nbsp; real(8):: DELTA,AM,D1,D2,D4<br />
&nbsp; real(8):: V1,DEE,FRAC<br />
&nbsp; real(8):: CN,SN,SSS,CN1,CN2,DF,DF1,DF2<br />
&nbsp; real(8):: FN,FNB,FNC,FND<br />
&nbsp; real(8):: EE<br />
&nbsp; integer(4):: LE,NE1,NE2<br />
&nbsp; !<br />
&nbsp; G(1)=1.0<br />
&nbsp; G(2)=1.0<br />
&nbsp; G(3)=1.0<br />
&nbsp; G(4)=1.0<br />
&nbsp; !<br />
&nbsp; S(1)=E(I1)<br />
&nbsp; S(2)=E(I2)<br />
&nbsp; S(3)=E(I3)<br />
&nbsp; S(4)=E(I4)<br />
&nbsp; F(1)=FK(I1)<br />
&nbsp; F(2)=FK(I2)<br />
&nbsp; F(3)=FK(I3)<br />
&nbsp; F(4)=FK(I4)<br />
&nbsp; FB(1)=FKB(I1)<br />
&nbsp; FB(2)=FKB(I2)<br />
&nbsp; FB(3)=FKB(I3)<br />
&nbsp; FB(4)=FKB(I4)<br />
&nbsp; FC(1)=FKC(I1)<br />
&nbsp; FC(2)=FKC(I2)<br />
&nbsp; FC(3)=FKC(I3)<br />
&nbsp; FC(4)=FKC(I4)<br />
&nbsp; !<br />
&nbsp; CALL SORT(S,F,FB,FC)<br />
&nbsp; !<br />
&nbsp; if( S(1)&gt;=(EM(NE)) ) return<br />
&nbsp; EB=EM(1)<br />
&nbsp; NE1=int ( (S(1)-EB)/DE )<br />
&nbsp; if( S(1)&lt;EB ) NE1=-1<br />
&nbsp; NE1=NE1+2<br />
&nbsp; NE2=NEMAX<br />
&nbsp; DO 25 LE=NE1,NE2<br />
&nbsp;&nbsp;&nbsp; EE=EM(LE)<br />
&nbsp;&nbsp;&nbsp; if( EE &lt;= S(1) ) goto 25<br />
&nbsp;&nbsp;&nbsp; if( EE &gt;= S(4) ) goto 20<br />
&nbsp;&nbsp;&nbsp; if( EE &lt;= S(2) ) goto 21<br />
&nbsp;&nbsp;&nbsp; if( EE &gt;= S(3) ) goto 22<br />
! CASE_2 E2 &lt;E&lt; E3<br />
&nbsp;&nbsp;&nbsp; DELTA=S(4)+S(3)-S(2)-S(1)<br />
&nbsp;&nbsp;&nbsp; AM=(S(4)*S(3)-S(2)*S(1))/DELTA<br />
&nbsp;&nbsp;&nbsp; D1=S(1)-AM<br />
&nbsp;&nbsp;&nbsp; D2=S(2)-AM<br />
&nbsp;&nbsp;&nbsp; V1=V/DELTA<br />
&nbsp;&nbsp;&nbsp; DEE=EE-AM<br />
&nbsp;&nbsp;&nbsp; FRAC=DEE*DEE/D2/D1<br />
&nbsp;&nbsp;&nbsp; CN=3.D0*V1*(1.D0-FRAC)<br />
&nbsp;&nbsp;&nbsp; SN=3.D0*V1*DEE-V1*(D1+D2+DEE*FRAC)<br />
&nbsp;&nbsp;&nbsp; if( ABS(S(2)-S(1)) &lt;= 0.0 ) then<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SSS=3.D0*V*(EE-S(1))/(S(3)-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CN1=SSS*(S(3)-EE)/(S(3)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CN2=SSS*(S(4)-EE)/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! FN<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF1=(F(2)-F(1))*( (S(3)-EE)/(S(3)-S(1))+ (S(4)-EE)/(S(4)-S(1)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +2*(F(3)-F(1))*(EE-S(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; (F(4)-F(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF2=(F(2)-F(1))*( (S(3)-EE)/(S(3)-S(1))+ (S(4)-EE)/(S(4)-S(1)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; (F(3)-F(1))*(EE-S(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +2*(F(4)-F(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FN=F(1)*CN+ (DF1*CN1+DF2*CN2)/3.D0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! FNB<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF1=(FB(2)-FB(1))*( (S(3)-EE)/(S(3)-S(1))+ (S(4)-EE)/(S(4)-S(1)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +2*(FB(3)-FB(1))*(EE-S(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; (FB(4)-FB(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF2=(FB(2)-FB(1))*( (S(3)-EE)/(S(3)-S(1))+ (S(4)-EE)/(S(4)-S(1)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; (FB(3)-FB(1))*(EE-S(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +2*(FB(4)-FB(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FNB=FB(1)*CN+(DF1*CN1+DF2*CN2)/3.D0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! FNC<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF1=(F(2)*FB(2)-F(1)*FB(1))*( (S(3)-EE)/(S(3)-S(1))+ (S(4)-EE)/(S(4)-S(1)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +2*(F(3)*FB(3)-F(1)*FB(1))*(EE-S(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; (F(4)*FB(4)-F(1)*FB(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF2=(F(2)*FB(2)-F(1)*FB(1))*( (S(3)-EE)/(S(3)-S(1))+ (S(4)-EE)/(S(4)-S(1)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; (F(3)*FB(3)-F(1)*FB(1))*(EE-S(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +2*(F(4)*FB(4)-F(1)*FB(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FNC=F(1)*FB(1)*CN+(DF1*CN1+DF2*CN2)/3.D0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! FND<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF1=(G(2)*FC(2)-G(1)*FC(1))*( (S(3)-EE)/(S(3)-S(1))+ (S(4)-EE)/(S(4)-S(1)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +2*(G(3)*FC(3)-G(1)*FC(1))*(EE-S(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; (G(4)*FC(4)-G(1)*FC(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF2=(G(2)*FC(2)-G(1)*FC(1))*( (S(3)-EE)/(S(3)-S(1))+ (S(4)-EE)/(S(4)-S(1)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp; (G(3)*FC(3)-G(1)*FC(1))*(EE-S(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +2*(G(4)*FC(4)-G(1)*FC(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FND=G(1)*FC(1)*CN+(DF1*CN1+DF2*CN2)/3.D0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto 23<br />
&nbsp;&nbsp;&nbsp; end if<br />
&nbsp;&nbsp;&nbsp; if( ABS(S(3)-S(2)) &lt;= 0.0) then<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! FN<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF=F(2)-F(1)+F(3)-F(1)+(F(4)-F(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FN=F(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! FNB<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF=FB(2)-FB(1)+FB(3)-FB(1)+(FB(4)-FB(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FNB=FB(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! FNC<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF=F(2)*FB(2)-F(1)*FB(1)+F(3)*FB(3)-F(1)*FB(1)+ &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (F(4)*FB(4)-F(1)*FB(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FNC=F(1)*FB(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! FND<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF=G(2)*FC(2)-G(1)*FC(1)+G(3)*FC(3)-G(1)*FC(1)+ &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (G(4)*FC(4)-G(1)*FC(1))*(EE-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FND=G(1)*FC(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto 23<br />
&nbsp;&nbsp;&nbsp; end if<br />
! CN1=small tri, CN2=big tri<br />
!&nbsp;&nbsp;&nbsp;&nbsp; CN2=3.D0*V1*(-DDE*DDE/D1+2.D0*DEE-D1) /(S(2)-S(1))<br />
&nbsp;&nbsp;&nbsp; CN2=3.D0*V *(EE-S(1))**2/(S(2)-S(1))/(S(3)-S(1))/(S(4)-S(1))<br />
&nbsp;&nbsp;&nbsp; CN1=CN2-CN<br />
&nbsp;&nbsp;&nbsp; ! FN<br />
&nbsp;&nbsp;&nbsp; DF2=( (F(2)-F(1))/(S(2)-S(1)) +(F(3)-F(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(F(4)-F(1))/(S(4)-S(1)) )*(EE-S(1))<br />
&nbsp;&nbsp;&nbsp; DF1=(F(2)-F(1))*( (EE-S(1))/(S(2)-S(1))+(S(3)-EE)/(S(3)-S(2)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(S(4)-EE)/(S(4)-S(2)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +( (F(3)-F(1))/(S(3)-S(2))+(F(4)-F(1))/(S(4)-S(2)) )*(EE-S(2))<br />
&nbsp;&nbsp;&nbsp; FN=F(1)*CN +(DF2*CN2-DF1*CN1)/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FNB<br />
&nbsp;&nbsp;&nbsp; DF2=( (FB(2)-FB(1))/(S(2)-S(1)) +(FB(3)-FB(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(FB(4)-FB(1))/(S(4)-S(1)) )*(EE-S(1))<br />
&nbsp;&nbsp;&nbsp; DF1=(FB(2)-FB(1))*( (EE-S(1))/(S(2)-S(1))+(S(3)-EE)/(S(3)-S(2)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(S(4)-EE)/(S(4)-S(2)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +( (FB(3)-FB(1))/(S(3)-S(2))+(FB(4)-FB(1))/(S(4)-S(2)) )*(EE-S(2))<br />
&nbsp;&nbsp;&nbsp; FNB=FB(1)*CN+(DF2*CN2-DF1*CN1)/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FNC<br />
&nbsp;&nbsp;&nbsp; DF2=( (F(2)*FB(2)-F(1)*FB(1))/(S(2)-S(1)) +(F(3)*FB(3)-F(1)*FB(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(F(4)*FB(4)-F(1)*FB(1))/(S(4)-S(1)) )*(EE-S(1))<br />
&nbsp;&nbsp;&nbsp; DF1=(F(2)*FB(2)-F(1)*FB(1))*( (EE-S(1))/(S(2)-S(1))+(S(3)-EE)/(S(3)-S(2)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(S(4)-EE)/(S(4)-S(2)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +( (F(3)*FB(3)-F(1)*FB(1))/(S(3)-S(2))+(F(4)*FB(4)-F(1)*FB(1))/ &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (S(4)-S(2)) )*(EE-S(2))<br />
&nbsp;&nbsp;&nbsp; FNC=F(1)*FB(1)*CN+(DF2*CN2-DF1*CN1)/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FND<br />
&nbsp;&nbsp;&nbsp; DF2=( (G(2)*FC(2)-G(1)*FC(1))/(S(2)-S(1)) +(G(3)*FC(3)-G(1)*FC(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(G(4)*FC(4)-G(1)*FC(1))/(S(4)-S(1)) )*(EE-S(1))<br />
&nbsp;&nbsp;&nbsp; DF1=(G(2)*FC(2)-G(1)*FC(1))*( (EE-S(1))/(S(2)-S(1))+(S(3)-EE)/(S(3)-S(2)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(S(4)-EE)/(S(4)-S(2)) ) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +( (G(3)*FC(3)-G(1)*FC(1))/(S(3)-S(2))+(G(4)*FC(4)-G(1)*FC(1))/ &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (S(4)-S(2)) )*(EE-S(2))<br />
&nbsp;&nbsp;&nbsp; FND=G(1)*FC(1)*CN+(DF2*CN2-DF1*CN1)/3.D0<br />
&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp; goto 23<br />
! CASE_3 E1&lt;E2&lt; E3&lt;E&lt;E4<br />
&nbsp;22 if( ABS(S(4)-S(3)) &lt;= 0.0 ) then<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CN=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SN=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FN=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FNB=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FNC=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FND=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto 23<br />
&nbsp;&nbsp;&nbsp; end if<br />
&nbsp;&nbsp;&nbsp; DELTA=S(4)+S(3)-S(2)-S(1)<br />
&nbsp;&nbsp;&nbsp; AM=(S(4)*S(3)-S(2)*S(1))/DELTA<br />
&nbsp;&nbsp;&nbsp; D4=S(4)-AM<br />
&nbsp;&nbsp;&nbsp; V1=V/DELTA<br />
&nbsp;&nbsp;&nbsp; DEE=EE-S(4)<br />
&nbsp;&nbsp;&nbsp; FRAC=DEE*DEE/D4/(S(4)-S(3))<br />
&nbsp;&nbsp;&nbsp; CN=3.D0*V1*FRAC<br />
&nbsp;&nbsp;&nbsp; SN=V1*(DELTA+DEE*FRAC)<br />
&nbsp;&nbsp;&nbsp; ! FN<br />
&nbsp;&nbsp;&nbsp; DF=(F(2)-F(1))*(S(4)-EE)/(S(4)-S(2)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(F(3)-F(1))*(S(4)-EE)/(S(4)-S(3)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(F(4)-F(1))*( (EE-S(1))/(S(4)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(EE-S(2))/(S(4)-S(2))+(EE-S(3))/(S(4)-S(3)) )<br />
&nbsp;&nbsp;&nbsp; FN=F(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FNB<br />
&nbsp;&nbsp;&nbsp; DF=(FB(2)-FB(1))*(S(4)-EE)/(S(4)-S(2)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(FB(3)-FB(1))*(S(4)-EE)/(S(4)-S(3)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(FB(4)-FB(1))*( (EE-S(1))/(S(4)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(EE-S(2))/(S(4)-S(2))+(EE-S(3))/(S(4)-S(3)) )<br />
&nbsp;&nbsp;&nbsp; FNB=FB(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FNC<br />
&nbsp;&nbsp;&nbsp; DF=(F(2)*FB(2)-F(1)*FB(1))*(S(4)-EE)/(S(4)-S(2)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(F(3)*FB(3)-F(1)*FB(1))*(S(4)-EE)/(S(4)-S(3)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(F(4)*FB(4)-F(1)*FB(1))*( (EE-S(1))/(S(4)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(EE-S(2))/(S(4)-S(2))+(EE-S(3))/(S(4)-S(3)) )<br />
&nbsp;&nbsp;&nbsp; FNC=F(1)*FB(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FND<br />
&nbsp;&nbsp;&nbsp; DF=(G(2)*FC(2)-G(1)*FC(1))*(S(4)-EE)/(S(4)-S(2)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(G(3)*FC(3)-G(1)*FC(1))*(S(4)-EE)/(S(4)-S(3)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(G(4)*FC(4)-G(1)*FC(1))*( (EE-S(1))/(S(4)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(EE-S(2))/(S(4)-S(2))+(EE-S(3))/(S(4)-S(3)) )<br />
&nbsp;&nbsp;&nbsp; FND=G(1)*FC(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp; goto 23<br />
! CASE_1 E1&lt;E&lt;E2 &lt;E3&lt;E4<br />
&nbsp;21 if( ABS(S(2)-S(1)) &lt;= 0.0 ) then<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CN=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SN=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FN=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FNB=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FNC=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FND=0.0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto 23<br />
&nbsp;&nbsp;&nbsp; endif<br />
&nbsp;&nbsp;&nbsp; DELTA=S(4)+S(3)-S(2)-S(1)<br />
&nbsp;&nbsp;&nbsp; AM=(S(4)*S(3)-S(2)*S(1))/DELTA<br />
&nbsp;&nbsp;&nbsp; D1=S(1)-AM<br />
&nbsp;&nbsp;&nbsp; V1=V/DELTA<br />
&nbsp;&nbsp;&nbsp; DEE=EE-S(1)<br />
&nbsp;&nbsp;&nbsp; FRAC=DEE*DEE/D1/(S(1)-S(2))<br />
&nbsp;&nbsp;&nbsp; CN=3.D0*V1*FRAC<br />
&nbsp;&nbsp;&nbsp; SN=V1*FRAC*DEE<br />
&nbsp;&nbsp;&nbsp; ! FN<br />
&nbsp;&nbsp;&nbsp; DF=( (F(2)-F(1))/(S(2)-S(1))+ (F(3)-F(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(F(4)-F(1))/(S(4)-S(1)) )*DEE<br />
&nbsp;&nbsp;&nbsp; FN=F(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FNB<br />
&nbsp;&nbsp;&nbsp; DF=( (FB(2)-FB(1))/(S(2)-S(1))+ (FB(3)-FB(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(FB(4)-FB(1))/(S(4)-S(1)) )*DEE<br />
&nbsp;&nbsp;&nbsp; FNB=FB(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FNC<br />
&nbsp;&nbsp;&nbsp; DF=( (F(2)*FB(2)-F(1)*FB(1))/(S(2)-S(1))+ (F(3)*FB(3)-F(1)*FB(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(F(4)*FB(4)-F(1)*FB(1))/(S(4)-S(1)) )*DEE<br />
&nbsp;&nbsp;&nbsp; FNC=F(1)*FB(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp; ! FND<br />
&nbsp;&nbsp;&nbsp; DF=( (G(2)*FC(2)-G(1)*FC(1))/(S(2)-S(1))+ (G(3)*FC(3)-G(1)*FC(1))/(S(3)-S(1)) &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +(G(4)*FC(4)-G(1)*FC(1))/(S(4)-S(1)) )*DEE<br />
&nbsp;&nbsp;&nbsp; FND=G(1)*FC(1)*CN+DF*CN/3.D0<br />
&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp; goto 23<br />
!<br />
&nbsp;20 SN =V<br />
&nbsp;&nbsp;&nbsp; CN =0.d0<br />
&nbsp;&nbsp;&nbsp; FN =0.d0<br />
&nbsp;&nbsp;&nbsp; FNB=0.d0<br />
&nbsp;&nbsp;&nbsp; FNC=0.d0<br />
&nbsp;&nbsp;&nbsp; FND=0.d0<br />
!<br />
&nbsp;23 SNT(LE) =SNT(LE) +SN !*IWW(LP)<br />
&nbsp;&nbsp;&nbsp; CNT(LE) =CNT(LE) +CN !*IWW(LP)<br />
&nbsp;&nbsp;&nbsp; FNT(LE) =FNT(LE) +FN !*IWW(LP)<br />
&nbsp;&nbsp;&nbsp; FNTB(LE)=FNTB(LE)+FNB !*IWW(LP)<br />
&nbsp;&nbsp;&nbsp; FNTC(LE)=FNTC(LE)+FNC !*IWW(LP)<br />
&nbsp;&nbsp;&nbsp; FNTD(LE)=FNTD(LE)+FND !*IWW(LP)<br />
&nbsp;25 CONTINUE<br />
&nbsp; return<br />
end subroutine PDNS<br />
!----------------------------------------------------------------------<br />
<br />
□ SORT: ソートのルーチン。昇順に並べる。<br />
!----------------------------------------------------------------------<br />
subroutine SORT(S,F,G,O)<br />
&nbsp; implicit none<br />
&nbsp; integer(4):: I,J,NP<br />
&nbsp; real(8),intent(inout):: S(4),F(4),G(4),O(4)<br />
&nbsp; real(8):: ST, FT, GT, OT<br />
&nbsp; DO J=1,3<br />
&nbsp;&nbsp;&nbsp; NP=4-J<br />
&nbsp;&nbsp;&nbsp; DO I=1,NP<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(S(I+1)&lt;S(I)) then<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ST=S(I)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FT=F(I)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GT=G(I)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OT=O(I)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(I)=S(I+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F(I)=F(I+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G(I)=G(I+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O(I)=O(I+1)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S(I+1)=ST<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F(I+1)=FT<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G(I+1)=GT<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O(I+1)=OT<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if<br />
&nbsp;&nbsp;&nbsp; end do<br />
&nbsp; end do<br />
&nbsp; return<br />
end subroutine SORT<br />
!----------------------------------------------------------------------<br />
--------------------------------------------------------------------------------